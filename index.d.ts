/*!
 * @lottie-animation-community/lottie-types - v1.2.0
 * Compiled Sun, 30 Mar 2025 09:21:16 UTC
 *
 * Generated by an automated process. DO NOT EDIT!
 *
 * Copyright 2022 Lottie Animation Community.
 *
 * Licensed under the MIT License,
 * You may obtain a copy of the License at:
 * https://github.com/lottie-animation-community/lottie-types/blob/main/LICENSE
 *
 * Type definitions for the Lottie animation format.
 * Definitions by: Aidos Sabit <https://github.com/aidosmf>.
 *
 * To report an issue with these types, please open a support ticket at:
 * https://github.com/lottie-animation-community/lottie-types/issues
 */
type AnimatedProperty = AnimatedProperty.Value;
declare namespace AnimatedProperty {
  /**
   * Bezier handle for keyframe interpolation
   */
  interface KeyframeBezierHandle {
    /**
     * Time component:\n0 means start time of the keyframe,\n1 means time of the next keyframe.
     *
     * @if type array
     * @then minItems: 1
     * @default 0
     */
    x: number[] | number;
    /**
     * Value interpolation component:\n0 means start value of the keyframe,\n1 means value at the next keyframe.
     *
     * @if type array
     * @then minItems: 1
     * @default 0
     */
    y: number[] | number;
  }
  /**
   * A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe
   *
   * 'i' and 'o' are not included in the last element of the keyframe array usually when the
   * Bezier curve is not closed, or when the last vertex is defined by the last element is the
   * same as the first vertex.
   *
   * @if "h": { "const": 0 | undefined }
   * @then 'i' and 'o'
   */
  interface KeyframeBase {
    /**
     * Time
     * @default 0
     */
    t: Helpers.Time;
    /**
     * Hold
     * @default 0
     */
    h?: Helpers.IntegerBoolean;
    /**
     * In Tangent
     *
     * Easing tangent going into the next keyframe
     *
     * @if "h": { "const": 0 | undefined }
     * @then 'i' is present
     */
    i?: KeyframeBezierHandle;
    /**
     * Out Tangent
     *
     * Easing tangent leaving the current keyframe
     *
     * @if "h": { "const": 0 | undefined }
     * @then 'o' is present
     */
    o?: KeyframeBezierHandle;
    /**
     * Start
     */
    s: number[] | Helpers.Bezier[];
  }
  /**
   * A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.
   */
  interface Keyframe extends KeyframeBase {
    /**
     * Value
     *
     * Value at this keyframe. Note the if the property is a scalar, keyframe values are still represented as arrays
     */
    s: number[];
    /**
     * End Value
     *
     * Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value
     *
     * @deprecated true
     */
    e?: number[];
  }
  /**
   * Keyframe holding Bezier objects
   */
  interface ShapeKeyframe extends KeyframeBase {
    /**
     * Keyframe end value
     *
     * depends on "v"
     */
    e?: Helpers.Bezier;
    /**
     * Start
     */
    s: Helpers.Bezier[];
  }
  interface Main
    extends Helpers.PropertyIndex,
      Helpers.VisualObject,
      Helpers.Expression {
    /**
     * Animated - Whether the property is animated
     * @default 0
     */
    a?: Helpers.IntegerBoolean;
    /**
     * 'k' is the list of keyframes that define the change and the rate of change of
     * an animated property between any given two frames. therefore, 'k' is require for
     * all animated properties.
     */
    k:
      | Keyframe[]
      | Helpers.ColorRgba
      | ShapeKeyframe[]
      | Helpers.Bezier
      | number[]
      | number;
    /**
     * Slot ID
     *
     * One of the ID in the file's slots
     */
    sid?: Helpers.SlotID;
  }
  /**
   * An animatable property that holds an array of numbers
   */
  interface MultiDimensional extends Main, Helpers.Length {
    /**
     * @if "a": { "const": 1  }
     * @then Animated value - Keyframe[];
     * @else Static Value
     */
    k: Keyframe[] | number[];
  }
  /**
   * An animatable property that holds a Color
   */
  interface Color extends Main {
    /**
     * @if "a": { "const": 1  }
     * @then Animated value - Keyframe[];
     * @else Static Value - Color
     */
    k: Keyframe[] | Helpers.ColorRgba;
  }
  /**
   * Represents colors and offsets in a gradient
   *
   * Colors are represented as a flat list interleaving offsets and color components in weird ways
   * There are two possible layouts:
   *
   * Without alpha, the colors are a sequence of offset, r, g, b
   *
   * With alpha, same as above but at the end of the list there is a sequence of offset, alpha.
   *
   */
  interface GradientColors {
    /**
     * Colors
     */
    k: MultiDimensional;
    /**
     * Count
     * Number of colors in `k`
     * @default 0
     */
    p: number;
  }
  interface PositionKeyframe extends Keyframe {
    /**
     * Value In Tangent
     * Tangent for values (eg: moving position around a curved path
     */
    ti?: number[];
    /**
     * Value Out Tangent
     * Tangent for values (eg: moving position around a curved path
     */
    to?: number[];
  }
  /**
   * An animatable property to represent a position in space
   */
  interface Position extends Main, Helpers.Length {
    /**
     * @if "a": { "const": 1  }
     * @then Animated Value - PositionKeyframe[]
     * @else Static Value - number[]
     */
    k: PositionKeyframe[] | number[];
  }
  /**
   * An animatable property that holds a Bezier
   */
  interface Shape extends Main {
    /**
     * @if "a": { "const": 1  }
     * @then Animated Value - ShapeKeyframe[]
     * @else Static Value - Bezier
     */
    k: ShapeKeyframe[] | Helpers.Bezier;
  }
  /**
   * An animatable property that holds a float
   */
  interface Value extends Main {
    /**
     * @if "a": { "const": 1  }
     * @then Animated Value - Keyframe[]
     * @else Static Value - number
     */
    k: Keyframe[] | number;
  }
  /**
   *  An animatable property that is split into individually anaimated components
   */
  interface SplitVector {
    /**
     * Split
     */
    s: true;
    x: Value;
    y: Value;
    z?: Value;
  }
}

/**
 * How masks interact with each other. See https://helpx.adobe.com/after-effects/using/alpha-channels-masks-mattes.html
 */
type MaskMode = Helpers.Values<typeof MaskMode>;
declare namespace MaskMode {
  type Value = MaskMode;
  const No = "n";
  type No = typeof No;
  const Add = "a";
  type Add = typeof Add;
  const Subtract = "s";
  type Subtract = typeof Subtract;
  const Intersect = "i";
  type Intersect = typeof Intersect;
  const Lighten = "l";
  type Lighten = typeof Lighten;
  const Darken = "d";
  type Darken = typeof Darken;
  const Difference = "f";
  type Difference = typeof Difference;
  /** @deprecated Use the {@linkcode MaskMode} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode MaskMode} namespace */
  namespace VALUE {
    const NO = "n";
    type NO = typeof NO;
    const ADD = "a";
    type ADD = typeof ADD;
    const SUBTRACT = "s";
    type SUBTRACT = typeof SUBTRACT;
    const INTERSECT = "i";
    type INTERSECT = typeof INTERSECT;
    const LIGHTEN = "l";
    type LIGHTEN = typeof LIGHTEN;
    const DARKEN = "d";
    type DARKEN = typeof DARKEN;
    const DIFFERENCE = "f";
    type DIFFERENCE = typeof DIFFERENCE;
  }
}

declare namespace Helpers {
  /**
   * Index used in expressions
   */
  type PropertyIndex = {
    ix?: number;
  };
  /**
   * Name, as seen from editors and the like
   * @note mainly for labeling
   */
  type Name = {
    nm?: string;
  };
  /**
   * Match name, used in expressions. Mainly for scripting
   * and packaging. Unique identifier
   */
  type MatchName = {
    mn?: string;
  };
  type Expression = {
    x?: string;
  };
  /**
   * @default 0
   */
  type Width = number;
  /**
   * @default 0
   */
  type Height = number;
  /**
   * @default ""
   */
  type ID = string;
  type Hidden = boolean;
  type Index = number;
  type CssClass = string;
  type InPoint = number;
  type OutPoint = number;
  /**
   * Framerate in frames per second
   * @default 60
   */
  type Framerate = {
    fr?: number;
  };
  /**
   * @default 0
   */
  type Time = number;
  type VisualObject = Name & MatchName;
  /**
   * Represents boolean values as an integer. 0 is false, 1 is true.
   * @default 0
   */
  type IntegerBoolean = 0 | 1;
  /**
   * Color as a [r, g, b] array with values in [0, 1]
   * @minimum 0
   * @maximum 1
   */
  type ColorRgba = [number, number, number] | [number, number, number, number];
  /**
   * Whether the animation has 3D layers. Lottie doesn't actually support 3D stuff so this should always be 0
   */
  type Threedimensional = {
    ddd?: IntegerBoolean;
  };
  /**
   * Number of components in the value arrays.\nIf present values will be truncated or expanded to match this length when accessed from expressions.
   * @type integer
   */
  type Length = {
    l?: number;
  };
  /**
   * Rotation in degrees, clockwise
   */
  type RotationClockwise = {
    r: AnimatedProperty.Value;
  };
  type RotationXYZ = {
    /**
     * X Rotation - Split rotation component
     */
    rx?: AnimatedProperty.Value;
    /**
     * Y Rotation - Split rotation component
     */
    ry?: AnimatedProperty.Value;
    /**
     * ZRotation - Split rotation component, equivalent to `r` when not split
     */
    rz?: AnimatedProperty.Value;
    /**
     * Orientation
     */
    or?: AnimatedProperty.MultiDimensional;
  };
  type TransformRotation = RotationClockwise | RotationXYZ;
  /**
   * Layer transform
   */
  type Transform = TransformRotation &
    VisualObject & {
      /**
       * Anchor point
       *
       * a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)
       */
      a?: AnimatedProperty.Position;
      /**
       * Scale factor, `[100, 100]` for no scaling
       */
      s?: AnimatedProperty.MultiDimensional;
      /**
       * Opacity
       */
      o?: AnimatedProperty.Value;
      /**
       * Skew
       *
       * Skew amount as an angle in degrees
       */
      sk?: AnimatedProperty.Value;
      /**
       * Skew Axis
       *
       * Direction along which skew is applied, in degrees (`0` skews along the X axis, `90` along the Y axis)
       */
      sa?: AnimatedProperty.Value;
      /**
       * Position - Translation or Translation with split components
       */
      p?: AnimatedProperty.Position | AnimatedProperty.SplitVector;
    };
  /**
   * Bezier shape used to mask/clip a layer
   */
  type Mask = Helpers.VisualObject & {
    /**
     * Inverted
     * @default false
     */
    inv?: boolean;
    /**
     * Mask Vertices
     */
    pt?: AnimatedProperty.Shape;
    /**
     * Opacity
     */
    o?: AnimatedProperty.Value;
    /**
     * Mode
     * @default 'i' (ModeIntersect)
     */
    mode?: MaskMode.Value;
    /**
     * Dilate
     */
    x?: AnimatedProperty.Value;
  };
  /**
   * Single bezier curve
   */
  interface Bezier {
    /**
     * Closed
     * @default False
     */
    c?: boolean;
    /**
     * In Tangents
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the `in` tangents relative to the corresponding `v`.
     *
     * @default []
     */
    i: number[][];
    /**
     * Out Tangents
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the `out` tangents relative to the corresponding `v`.
     */
    o: number[][];
    /**
     * Vertices
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the bezier path
     */
    v: number[][];
  }
  /**
   * One of the ID in the file's slots
   */
  type SlotID = string;
  /**
   * Used for record enums. Excludes uppercase keys used for backwards compatibility from the record.
   */
  type Values<T extends Record<string, any>> =
    T extends Record<infer K, any>
      ? K extends string
        ? T[ExcludeUppercase<K>]
        : never
      : never;
  type ExcludeUppercase<T extends string> = T extends Uppercase<T> ? never : T;
}

/**
 * Layer and shape blend mode
 */
type BlendMode = Helpers.Values<typeof BlendMode>;
declare namespace BlendMode {
  type Value = BlendMode;
  const Normal = 0;
  type Normal = typeof Normal;
  const Multiply = 1;
  type Multiply = typeof Multiply;
  const Screen = 2;
  type Screen = typeof Screen;
  const Overlay = 3;
  type Overlay = typeof Overlay;
  const Darken = 4;
  type Darken = typeof Darken;
  const Lighten = 5;
  type Lighten = typeof Lighten;
  const ColorDodge = 6;
  type ColorDodge = typeof ColorDodge;
  const ColorBurn = 7;
  type ColorBurn = typeof ColorBurn;
  const HardLight = 8;
  type HardLight = typeof HardLight;
  const SoftLight = 9;
  type SoftLight = typeof SoftLight;
  const Difference = 10;
  type Difference = typeof Difference;
  const Exclusion = 11;
  type Exclusion = typeof Exclusion;
  const Hue = 12;
  type Hue = typeof Hue;
  const Saturation = 13;
  type Saturation = typeof Saturation;
  const Color = 14;
  type Color = typeof Color;
  const Luminosity = 15;
  type Luminosity = typeof Luminosity;
  const Add = 16;
  type Add = typeof Add;
  const HardMix = 17;
  type HardMix = typeof HardMix;
  /** @deprecated Use the {@linkcode BlendMode} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode BlendMode} namespace */
  namespace VALUE {
    const NORMAL = 0;
    type NORMAL = typeof NORMAL;
    const MULTIPLY = 1;
    type MULTIPLY = typeof MULTIPLY;
    const SCREEN = 2;
    type SCREEN = typeof SCREEN;
    const OVERLAY = 3;
    type OVERLAY = typeof OVERLAY;
    const DARKEN = 4;
    type DARKEN = typeof DARKEN;
    const LIGHTEN = 5;
    type LIGHTEN = typeof LIGHTEN;
    const COLOR_DODGE = 6;
    type COLOR_DODGE = typeof COLOR_DODGE;
    const COLOR_BURN = 7;
    type COLOR_BURN = typeof COLOR_BURN;
    const HARD_LIGHT = 8;
    type HARD_LIGHT = typeof HARD_LIGHT;
    const SOFT_LIGHT = 9;
    type SOFT_LIGHT = typeof SOFT_LIGHT;
    const DIFFERENCE = 10;
    type DIFFERENCE = typeof DIFFERENCE;
    const EXCLUSION = 11;
    type EXCLUSION = typeof EXCLUSION;
    const HUE = 12;
    type HUE = typeof HUE;
    const SATURATION = 13;
    type SATURATION = typeof SATURATION;
    const COLOR = 14;
    type COLOR = typeof COLOR;
    const LUMINOSITY = 15;
    type LUMINOSITY = typeof LUMINOSITY;
    const ADD = 16;
    type ADD = typeof ADD;
    const HARD_MIX = 17;
    type HARD_MIX = typeof HARD_MIX;
  }
}

/**
 * How to stack copies in a repeater
 */
type Composite = Helpers.Values<typeof Composite>;
declare namespace Composite {
  type Value = Composite;
  const Above = 1;
  type Above = typeof Above;
  const Below = 2;
  type Below = typeof Below;
  /** @deprecated Use the {@linkcode Composite} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode Composite} namespace */
  namespace VALUE {
    const ABOVE = 1;
    type ABOVE = typeof ABOVE;
    const BELOW = 2;
    type BELOW = typeof BELOW;
  }
}

type EffectValueType = Helpers.Values<typeof EffectValueType>;
declare namespace EffectValueType {
  type Value = EffectValueType;
  const Slider = 0;
  type Slider = typeof Slider;
  const Angle = 1;
  type Angle = typeof Angle;
  const Color = 2;
  type Color = typeof Color;
  const Point = 3;
  type Point = typeof Point;
  const Checkbox = 4;
  type Checkbox = typeof Checkbox;
  const Ignored = 6;
  type Ignored = typeof Ignored;
  const Dropdown = 7;
  type Dropdown = typeof Dropdown;
  const Layer = 10;
  type Layer = typeof Layer;
  /** @deprecated Use the {@linkcode EffectValueType} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode EffectValueType} namespace */
  namespace VALUE {
    const SLIDER = 0;
    type SLIDER = typeof SLIDER;
    const ANGLE = 1;
    type ANGLE = typeof ANGLE;
    const COLOR = 2;
    type COLOR = typeof COLOR;
    const POINT = 3;
    type POINT = typeof POINT;
    const CHECKBOX = 4;
    type CHECKBOX = typeof CHECKBOX;
    const IGNORED = 6;
    type IGNORED = typeof IGNORED;
    const DROPDOWN = 7;
    type DROPDOWN = typeof DROPDOWN;
    const LAYER = 10;
    type LAYER = typeof LAYER;
  }
}

type EffectType = Helpers.Values<typeof EffectType>;
declare namespace EffectType {
  type Value = EffectType;
  const Custom = 5;
  type Custom = typeof Custom;
  const PaintOverTransparent = 7;
  type PaintOverTransparent = typeof PaintOverTransparent;
  const Tint = 20;
  type Tint = typeof Tint;
  const Fill = 21;
  type Fill = typeof Fill;
  const Stroke = 22;
  type Stroke = typeof Stroke;
  const Tritone = 23;
  type Tritone = typeof Tritone;
  const ProLevels = 24;
  type ProLevels = typeof ProLevels;
  const DropShadow = 25;
  type DropShadow = typeof DropShadow;
  const RadialWipe = 26;
  type RadialWipe = typeof RadialWipe;
  const DisplacementMap = 27;
  type DisplacementMap = typeof DisplacementMap;
  const Matte3 = 28;
  type Matte3 = typeof Matte3;
  const GaussianBlur = 29;
  type GaussianBlur = typeof GaussianBlur;
  const MeshWarp = 31;
  type MeshWarp = typeof MeshWarp;
  const Wavy = 32;
  type Wavy = typeof Wavy;
  const Spherize = 33;
  type Spherize = typeof Spherize;
  const Puppet = 34;
  type Puppet = typeof Puppet;
  /** @deprecated Use the {@linkcode EffectType} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode EffectType} namespace */
  namespace VALUE {
    const CUSTOM = 5;
    type CUSTOM = typeof CUSTOM;
    const PAINT_OVER_TRANSPARENT = 7;
    type PAINT_OVER_TRANSPARENT = typeof PAINT_OVER_TRANSPARENT;
    const TINT = 20;
    type TINT = typeof TINT;
    const FILL = 21;
    type FILL = typeof FILL;
    const STROKE = 22;
    type STROKE = typeof STROKE;
    const TRITONE = 23;
    type TRITONE = typeof TRITONE;
    const PRO_LEVELS = 24;
    type PRO_LEVELS = typeof PRO_LEVELS;
    const DROP_SHADOW = 25;
    type DROP_SHADOW = typeof DROP_SHADOW;
    const RADIAL_WIPE = 26;
    type RADIAL_WIPE = typeof RADIAL_WIPE;
    const DISPLACEMENT_MAP = 27;
    type DISPLACEMENT_MAP = typeof DISPLACEMENT_MAP;
    const MATTE3 = 28;
    type MATTE3 = typeof MATTE3;
    const GAUSSIAN_BLUR = 29;
    type GAUSSIAN_BLUR = typeof GAUSSIAN_BLUR;
    const MESH_WARP = 31;
    type MESH_WARP = typeof MESH_WARP;
    const WAVY = 32;
    type WAVY = typeof WAVY;
    const SPHERIZE = 33;
    type SPHERIZE = typeof SPHERIZE;
    const PUPPET = 34;
    type PUPPET = typeof PUPPET;
  }
}

/**
 * Rule used to handle multiple shapes rendered with the same fill object
 */
type FillRule = Helpers.Values<typeof FillRule>;
declare namespace FillRule {
  type Value = FillRule;
  const NonZero = 1;
  type NonZero = typeof NonZero;
  const EvenOdd = 2;
  type EvenOdd = typeof EvenOdd;
  /** @deprecated Use the {@linkcode FillRule} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode FillRule} namespace */
  namespace VALUE {
    const NON_ZERO = 1;
    type NON_ZERO = typeof NON_ZERO;
    const EVEN_ODD = 2;
    type EVEN_ODD = typeof EVEN_ODD;
  }
}

/**
 * Type of a gradient
 *
 * @default 1
 */
type GradientType = Helpers.Values<typeof GradientType>;
declare namespace GradientType {
  type Value = GradientType;
  const Linear = 1;
  type Linear = typeof Linear;
  const Radial = 2;
  type Radial = typeof Radial;
  /** @deprecated Use the {@linkcode GradientType} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode GradientType} namespace */
  namespace VALUE {
    const LINEAR = 1;
    type LINEAR = typeof LINEAR;
    const RADIAL = 2;
    type RADIAL = typeof RADIAL;
  }
}

type LayerType = Helpers.Values<typeof LayerType>;
declare namespace LayerType {
  type Value = LayerType;
  const Precomposition = 0;
  type Precomposition = typeof Precomposition;
  const SolidColor = 1;
  type SolidColor = typeof SolidColor;
  const Image = 2;
  type Image = typeof Image;
  const Null = 3;
  type Null = typeof Null;
  const Shape = 4;
  type Shape = typeof Shape;
  const Text = 5;
  type Text = typeof Text;
  const Audio = 6;
  type Audio = typeof Audio;
  const VideoPlaceholder = 7;
  type VideoPlaceholder = typeof VideoPlaceholder;
  const ImageSequence = 8;
  type ImageSequence = typeof ImageSequence;
  const Video = 9;
  type Video = typeof Video;
  const ImagePlaceholder = 10;
  type ImagePlaceholder = typeof ImagePlaceholder;
  const Guide = 11;
  type Guide = typeof Guide;
  const Adjustment = 12;
  type Adjustment = typeof Adjustment;
  const Camera = 13;
  type Camera = typeof Camera;
  const Light = 14;
  type Light = typeof Light;
  const Data = 15;
  type Data = typeof Data;
  /** @deprecated Use the {@linkcode LayerType} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode LayerType} namespace */
  namespace VALUE {
    const PRECOMPOSITION = 0;
    type PRECOMPOSITION = typeof PRECOMPOSITION;
    const SOLID_COLOR = 1;
    type SOLID_COLOR = typeof SOLID_COLOR;
    const IMAGE = 2;
    type IMAGE = typeof IMAGE;
    const NULL = 3;
    type NULL = typeof NULL;
    const SHAPE = 4;
    type SHAPE = typeof SHAPE;
    const TEXT = 5;
    type TEXT = typeof TEXT;
    const AUDIO = 6;
    type AUDIO = typeof AUDIO;
    const VIDEO_PLACEHOLDER = 7;
    type VIDEO_PLACEHOLDER = typeof VIDEO_PLACEHOLDER;
    const IMAGE_SEQUENCE = 8;
    type IMAGE_SEQUENCE = typeof IMAGE_SEQUENCE;
    const VIDEO = 9;
    type VIDEO = typeof VIDEO;
    const IMAGE_PLACEHOLDER = 10;
    type IMAGE_PLACEHOLDER = typeof IMAGE_PLACEHOLDER;
    const GUIDE = 11;
    type GUIDE = typeof GUIDE;
    const ADJUSTMENT = 12;
    type ADJUSTMENT = typeof ADJUSTMENT;
    const CAMERA = 13;
    type CAMERA = typeof CAMERA;
    const LIGHT = 14;
    type LIGHT = typeof LIGHT;
    const DATA = 15;
    type DATA = typeof DATA;
  }
}

/**
 * Style at the end of a stoked line
 */
type LineCap = Helpers.Values<typeof LineCap>;
declare namespace LineCap {
  type Value = LineCap;
  const Butt = 1;
  type Butt = typeof Butt;
  const Round = 2;
  type Round = typeof Round;
  const Square = 3;
  type Square = typeof Square;
  /** @deprecated Use the {@linkcode LineCap} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode LineCap} namespace */
  namespace VALUE {
    const BUTT = 1;
    type BUTT = typeof BUTT;
    const ROUND = 2;
    type ROUND = typeof ROUND;
    const SQUARE = 3;
    type SQUARE = typeof SQUARE;
  }
}

/**
 * Style at a sharp corner of a stoked line
 */
type LineJoin = Helpers.Values<typeof LineJoin>;
declare namespace LineJoin {
  type Value = LineJoin;
  const Miter = 1;
  type Miter = typeof Miter;
  const Round = 2;
  type Round = typeof Round;
  const Bevel = 3;
  type Bevel = typeof Bevel;
  /** @deprecated Use the {@linkcode LineJoin} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode LineJoin} namespace */
  namespace VALUE {
    const MITER = 1;
    type MITER = typeof MITER;
    const ROUND = 2;
    type ROUND = typeof ROUND;
    const BEVEL = 3;
    type BEVEL = typeof BEVEL;
  }
}

/**
 * How a layer should mask another layer
 */
type MatteMode = Helpers.Values<typeof MatteMode>;
declare namespace MatteMode {
  type Value = MatteMode;
  const Normal = 0;
  type Normal = typeof Normal;
  const Alpha = 1;
  type Alpha = typeof Alpha;
  const InvertedAlpha = 2;
  type InvertedAlpha = typeof InvertedAlpha;
  const Luma = 3;
  type Luma = typeof Luma;
  const InvertedLuma = 4;
  type InvertedLuma = typeof InvertedLuma;
  /** @deprecated Use the {@linkcode MatteMode} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode MatteMode} namespace */
  namespace VALUE {
    const NORMAL = 0;
    type NORMAL = typeof NORMAL;
    const ALPHA = 1;
    type ALPHA = typeof ALPHA;
    const INVERTED_ALPHA = 2;
    type INVERTED_ALPHA = typeof INVERTED_ALPHA;
    const LUMA = 3;
    type LUMA = typeof LUMA;
    const INVERTED_LUMA = 4;
    type INVERTED_LUMA = typeof INVERTED_LUMA;
  }
}

/**
 * Star type, `1` for Star, `2` for Polygon
 */
type PolyStarType = Helpers.Values<typeof PolyStarType>;
declare namespace PolyStarType {
  type Value = PolyStarType;
  const Star = 1;
  type Star = typeof Star;
  const Polygon = 2;
  type Polygon = typeof Polygon;
  /** @deprecated Use the {@linkcode PolyStarType} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode PolyStarType} namespace */
  namespace VALUE {
    const STAR = 1;
    type STAR = typeof STAR;
    const POLYGON = 2;
    type POLYGON = typeof POLYGON;
  }
}

/**
 * Drawing direction of the shape curve, useful for trim path
 */
type ShapeDirection = Helpers.Values<typeof ShapeDirection>;
declare namespace ShapeDirection {
  type Value = ShapeDirection;
  /**
   * Default Clockwise
   */
  const Normal = 0;
  type Normal = typeof Normal;
  /**
   * Usually clockwise
   */
  const Clockwise = 1;
  type Clockwise = typeof Clockwise;
  /**
   * Usually counter clockwise
   */
  const ClockwiseReversed = 3;
  type ClockwiseReversed = typeof ClockwiseReversed;
  /** @deprecated Use the {@linkcode ShapeDirection} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode ShapeDirection} namespace */
  namespace VALUE {
    const NORMAL = 0;
    type NORMAL = typeof NORMAL;
    const CLOCKWISE = 1;
    type CLOCKWISE = typeof CLOCKWISE;
    const CLOCKWISE_REVERSED = 3;
    type CLOCKWISE_REVERSED = typeof CLOCKWISE_REVERSED;
  }
}

type ShapeType = Helpers.Values<typeof ShapeType>;
declare namespace ShapeType {
  type Value = ShapeType;
  const Rectangle = "rc";
  type Rectangle = typeof Rectangle;
  const Ellipse = "el";
  type Ellipse = typeof Ellipse;
  const PolygonStar = "sr";
  type PolygonStar = typeof PolygonStar;
  const Path = "sh";
  type Path = typeof Path;
  const Fill = "fl";
  type Fill = typeof Fill;
  const Stroke = "st";
  type Stroke = typeof Stroke;
  const GradientFill = "gf";
  type GradientFill = typeof GradientFill;
  const GradientStroke = "gs";
  type GradientStroke = typeof GradientStroke;
  const Group = "gr";
  type Group = typeof Group;
  const Transform = "tr";
  type Transform = typeof Transform;
  const RoundedCorners = "rd";
  type RoundedCorners = typeof RoundedCorners;
  const PuckerBloat = "pb";
  type PuckerBloat = typeof PuckerBloat;
  const Merge = "mm";
  type Merge = typeof Merge;
  const Twist = "tw";
  type Twist = typeof Twist;
  const OffsetPath = "op";
  type OffsetPath = typeof OffsetPath;
  const ZigZag = "zz";
  type ZigZag = typeof ZigZag;
  const Modifier = "";
  type Modifier = typeof Modifier;
  const Repeater = "rp";
  type Repeater = typeof Repeater;
  const Trim = "tm";
  type Trim = typeof Trim;
  /** @deprecated Use the {@linkcode ShapeType} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode ShapeType} namespace */
  namespace VALUE {
    const RECTANGLE = "rc";
    type RECTANGLE = typeof RECTANGLE;
    const ELLIPSE = "el";
    type ELLIPSE = typeof ELLIPSE;
    const POLYGON_STAR = "sr";
    type POLYGON_STAR = typeof POLYGON_STAR;
    const PATH = "sh";
    type PATH = typeof PATH;
    const FILL = "fl";
    type FILL = typeof FILL;
    const STROKE = "st";
    type STROKE = typeof STROKE;
    const GRADIENT_FILL = "gf";
    type GRADIENT_FILL = typeof GRADIENT_FILL;
    const GRADIENT_STROKE = "gs";
    type GRADIENT_STROKE = typeof GRADIENT_STROKE;
    const GROUP = "gr";
    type GROUP = typeof GROUP;
    const TRANSFORM = "tr";
    type TRANSFORM = typeof TRANSFORM;
    const ROUNDED_CORNERS = "rd";
    type ROUNDED_CORNERS = typeof ROUNDED_CORNERS;
    const PUCKER_BLOAT = "pb";
    type PUCKER_BLOAT = typeof PUCKER_BLOAT;
    const MERGE = "mm";
    type MERGE = typeof MERGE;
    const TWIST = "tw";
    type TWIST = typeof TWIST;
    const OFFSET_PATH = "op";
    type OFFSET_PATH = typeof OFFSET_PATH;
    const ZIG_ZAG = "zz";
    type ZIG_ZAG = typeof ZIG_ZAG;
    const MODIFIER = "";
    type MODIFIER = typeof MODIFIER;
    const REPEATER = "rp";
    type REPEATER = typeof REPEATER;
    const TRIM = "tm";
    type TRIM = typeof TRIM;
  }
}

/**
 * Type of a dash item in a stroked line
 */
type StrokeDashType = Helpers.Values<typeof StrokeDashType>;
declare namespace StrokeDashType {
  type Value = StrokeDashType;
  const Default = "d";
  type Default = typeof Default;
  const Gap = "g";
  type Gap = typeof Gap;
  const Offset = "o";
  type Offset = typeof Offset;
  /** @deprecated Use the {@linkcode StrokeDashType} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode StrokeDashType} namespace */
  namespace VALUE {
    const DEFAULT = "d";
    type DEFAULT = typeof DEFAULT;
    const GAP = "g";
    type GAP = typeof GAP;
    const OFFSET = "o";
    type OFFSET = typeof OFFSET;
  }
}

type TextType = Helpers.Values<typeof TextType>;
declare namespace TextType {
  type Based = Helpers.Values<typeof Based>;
  namespace Based {
    type Value = Based;
    const Characters = 1;
    type Characters = typeof Characters;
    const CharacterExcludingSpaces = 2;
    type CharacterExcludingSpaces = typeof CharacterExcludingSpaces;
    const Words = 3;
    type Words = typeof Words;
    const Lines = 4;
    type Lines = typeof Lines;
  }
  /** @deprecated Use the {@linkcode TextType.Based} type */
  type BASED = Helpers.Values<typeof BASED>;
  /** @deprecated Use the {@linkcode TextType.Based} namespace */
  namespace BASED {
    const CHARACTERS = 1;
    type CHARACTERS = typeof CHARACTERS;
    const CHARACTER_EXCLUDING_SPACES = 2;
    type CHARACTER_EXCLUDING_SPACES = typeof CHARACTER_EXCLUDING_SPACES;
    const WORDS = 3;
    type WORDS = typeof WORDS;
    const LINES = 4;
    type LINES = typeof LINES;
  }
  /**
   * @default 0
   */
  type Caps = Helpers.Values<typeof Caps>;
  namespace Caps {
    type Value = Caps;
    const Regular = 0;
    type Regular = typeof Regular;
    const AllCaps = 1;
    type AllCaps = typeof AllCaps;
    const SmallCaps = 2;
    type SmallCaps = typeof SmallCaps;
  }
  /** @deprecated Use the {@linkcode TextType.Caps} type */
  type TEXT_CAPS = Helpers.Values<typeof TEXT_CAPS>;
  /** @deprecated Use the {@linkcode TextType.Caps} namespace */
  namespace TEXT_CAPS {
    const REGULAR = 0;
    type REGULAR = typeof REGULAR;
    const ALL_CAPS = 1;
    type ALL_CAPS = typeof ALL_CAPS;
    const SMALL_CAPS = 2;
    type SMALL_CAPS = typeof SMALL_CAPS;
  }
  type Grouping = Helpers.Values<typeof Grouping>;
  namespace Grouping {
    type Value = Grouping;
    const Characters = 1;
    type Characters = typeof Characters;
    const Word = 2;
    type Word = typeof Word;
    const Line = 3;
    type Line = typeof Line;
    const All = 4;
    type All = typeof All;
  }
  /** @deprecated Use the {@linkcode TextType.Grouping} type */
  type GROUPING = Helpers.Values<typeof GROUPING>;
  /** @deprecated Use the {@linkcode TextType.Grouping} namespace */
  namespace GROUPING {
    const CHARACTERS = 1;
    type CHARACTERS = typeof CHARACTERS;
    const WORD = 2;
    type WORD = typeof WORD;
    const LINE = 3;
    type LINE = typeof LINE;
    const ALL = 4;
    type ALL = typeof ALL;
  }
  /**
   * Text alignment / justification
   *
   * @default 0
   */
  type Justify = Helpers.Values<typeof Justify>;
  namespace Justify {
    type Value = Justify;
    const Left = 0;
    type Left = typeof Left;
    const Right = 1;
    type Right = typeof Right;
    const Center = 2;
    type Center = typeof Center;
    const WithLastLineLeft = 3;
    type WithLastLineLeft = typeof WithLastLineLeft;
    const WithLastLineRight = 4;
    type WithLastLineRight = typeof WithLastLineRight;
    const WithLastLineCenter = 5;
    type WithLastLineCenter = typeof WithLastLineCenter;
    const WithLastLineFull = 6;
    type WithLastLineFull = typeof WithLastLineFull;
  }
  /** @deprecated Use the {@linkcode TextType.Justify} type */
  type JUSTIFY = Helpers.Values<typeof JUSTIFY>;
  /** @deprecated Use the {@linkcode TextType.Justify} namespace */
  namespace JUSTIFY {
    const LEFT = 0;
    type LEFT = typeof LEFT;
    const RIGHT = 1;
    type RIGHT = typeof RIGHT;
    const CENTER = 2;
    type CENTER = typeof CENTER;
    const WITH_LAST_LINE_LEFT = 3;
    type WITH_LAST_LINE_LEFT = typeof WITH_LAST_LINE_LEFT;
    const WITH_LAST_LINE_RIGHT = 4;
    type WITH_LAST_LINE_RIGHT = typeof WITH_LAST_LINE_RIGHT;
    const WITH_LAST_LINE_CENTER = 5;
    type WITH_LAST_LINE_CENTER = typeof WITH_LAST_LINE_CENTER;
    const WITH_LAST_LINE_FULL = 6;
    type WITH_LAST_LINE_FULL = typeof WITH_LAST_LINE_FULL;
  }
  type Shape = Helpers.Values<typeof Shape>;
  namespace Shape {
    type Value = Shape;
    const Square = 1;
    type Square = typeof Square;
    const RampUp = 2;
    type RampUp = typeof RampUp;
    const RampDown = 3;
    type RampDown = typeof RampDown;
    const Triangle = 4;
    type Triangle = typeof Triangle;
    const Round = 5;
    type Round = typeof Round;
    const Smooth = 6;
    type Smooth = typeof Smooth;
  }
  /** @deprecated Use the {@linkcode TextType.Shape} type */
  type SHAPE = Helpers.Values<typeof SHAPE>;
  /** @deprecated Use the {@linkcode TextType.Shape} namespace */
  namespace SHAPE {
    const SQUARE = 1;
    type SQUARE = typeof SQUARE;
    const RAMP_UP = 2;
    type RAMP_UP = typeof RAMP_UP;
    const RAMP_DOWN = 3;
    type RAMP_DOWN = typeof RAMP_DOWN;
    const TRIANGLE = 4;
    type TRIANGLE = typeof TRIANGLE;
    const ROUND = 5;
    type ROUND = typeof ROUND;
    const SMOOTH = 6;
    type SMOOTH = typeof SMOOTH;
  }
  type FontPathOrigin = Helpers.Values<typeof FontPathOrigin>;
  namespace FontPathOrigin {
    type Value = FontPathOrigin;
    const Local = 0;
    type Local = typeof Local;
    const CssUrl = 1;
    type CssUrl = typeof CssUrl;
    const ScriptUrl = 2;
    type ScriptUrl = typeof ScriptUrl;
    const FontUrl = 3;
    type FontUrl = typeof FontUrl;
  }
  /** @deprecated Use the {@linkcode TextType.FontPathOrigin} type */
  type FONT_PATH_ORIGIN = Helpers.Values<typeof FONT_PATH_ORIGIN>;
  /** @deprecated Use the {@linkcode TextType.FontPathOrigin} namespace */
  namespace FONT_PATH_ORIGIN {
    const LOCAL = 0;
    type LOCAL = typeof LOCAL;
    const CSS_URL = 1;
    type CSS_URL = typeof CSS_URL;
    const SCRIPT_URL = 2;
    type SCRIPT_URL = typeof SCRIPT_URL;
    const FONT_URL = 3;
    type FONT_URL = typeof FONT_URL;
  }
  type VerticalJustify = Helpers.Values<typeof VerticalJustify>;
  namespace VerticalJustify {
    type Value = VerticalJustify;
    const Top = 0;
    type Top = typeof Top;
    const Center = 1;
    type Center = typeof Center;
    const Bottom = 2;
    type Bottom = typeof Bottom;
  }
  /** @deprecated Use the {@linkcode TextType.VerticalJustify} type */
  type VERTICAL_JUSTIFY = Helpers.Values<typeof VERTICAL_JUSTIFY>;
  /** @deprecated Use the {@linkcode TextType.VerticalJustify} namespace */
  namespace VERTICAL_JUSTIFY {
    const TOP = 0;
    type TOP = typeof TOP;
    const CENTER = 1;
    type CENTER = typeof CENTER;
    const BOTTOM = 2;
    type BOTTOM = typeof BOTTOM;
  }
  type RangeSelectorMode = Helpers.Values<typeof RangeSelectorMode>;
  namespace RangeSelectorMode {
    type Value = RangeSelectorMode;
    const Add = 0;
    type Add = typeof Add;
    const Subtract = 1;
    type Subtract = typeof Subtract;
    const Intersect = 2;
    type Intersect = typeof Intersect;
    const Min = 3;
    type Min = typeof Min;
    const Max = 4;
    type Max = typeof Max;
    const Difference = 5;
    type Difference = typeof Difference;
  }
  /** @deprecated Use the {@linkcode TextType.RangeSelectorMode} type */
  type RANGE_SELECTOR_MODE = Helpers.Values<typeof RANGE_SELECTOR_MODE>;
  /** @deprecated Use the {@linkcode TextType.RangeSelectorMode} namespace */
  namespace RANGE_SELECTOR_MODE {
    const ADD = 0;
    type ADD = typeof ADD;
    const SUBTRACT = 1;
    type SUBTRACT = typeof SUBTRACT;
    const INTERSECT = 2;
    type INTERSECT = typeof INTERSECT;
    const MIN = 3;
    type MIN = typeof MIN;
    const MAX = 4;
    type MAX = typeof MAX;
    const DIFFERENCE = 5;
    type DIFFERENCE = typeof DIFFERENCE;
  }
  /** @deprecated Use {@linkcode TextType.Based.Characters} or {@linkcode TextType.Grouping.Characters} */
  const Characters = 1;
  type Characters = typeof Characters;
  /** @deprecated Use {@linkcode TextType.Based.CharacterExcludingSpaces} */
  const CharacterExcludingSpaces = 2;
  type CharacterExcludingSpaces = typeof CharacterExcludingSpaces;
  /** @deprecated Use {@linkcode TextType.Based.Words} */
  const Words = 3;
  type Words = typeof Words;
  /** @deprecated Use {@linkcode TextType.Based.Lines} */
  const Lines = 4;
  type Lines = typeof Lines;
  /** @deprecated Use {@linkcode TextType.Grouping.Word} */
  const Word = 2;
  type Word = typeof Word;
  /** @deprecated Use {@linkcode TextType.Grouping.Line} */
  const Line = 3;
  type Line = typeof Line;
  /** @deprecated Use {@linkcode TextType.Grouping.All} */
  const All = 4;
  type All = typeof All;
  /** @deprecated Use {@linkcode TextType.Justify.Left} */
  const Left = 0;
  type Left = typeof Left;
  /** @deprecated Use {@linkcode TextType.Justify.Right} */
  const Right = 1;
  type Right = typeof Right;
  /** @deprecated Use {@linkcode TextType.Justify.Center} */
  const Center = 2;
  type Center = typeof Center;
  /** @deprecated Use {@linkcode TextType.Justify.WithLastLineLeft} */
  const WithLastLineLeft = 3;
  type WithLastLineLeft = typeof WithLastLineLeft;
  /** @deprecated Use {@linkcode TextType.Justify.WithLastLineRight} */
  const WithLastLineRight = 4;
  type WithLastLineRight = typeof WithLastLineRight;
  /** @deprecated Use {@linkcode TextType.Justify.WithLastLineCenter} */
  const WithLastLineCenter = 5;
  type WithLastLineCenter = typeof WithLastLineCenter;
  /** @deprecated Use {@linkcode TextType.Justify.WithLastLineFull} */
  const WithLastLineFull = 6;
  type WithLastLineFull = typeof WithLastLineFull;
  /** @deprecated Use {@linkcode TextType.Shape.Square} */
  const Square = 1;
  type Square = typeof Square;
  /** @deprecated Use {@linkcode TextType.Shape.RampUp} */
  const RampUp = 2;
  type RampUp = typeof RampUp;
  /** @deprecated Use {@linkcode TextType.Shape.RampDown} */
  const RampDown = 3;
  type RampDown = typeof RampDown;
  /** @deprecated Use {@linkcode TextType.Shape.Triangle} */
  const Triangle = 4;
  type Triangle = typeof Triangle;
  /** @deprecated Use {@linkcode TextType.Shape.Round} */
  const Round = 5;
  type Round = typeof Round;
  /** @deprecated Use {@linkcode TextType.Shape.Smooth} */
  const Smooth = 6;
  type Smooth = typeof Smooth;
  /** @deprecated Use {@linkcode TextType.FontPathOrigin.Local} */
  const Local = 0;
  type Local = typeof Local;
  /** @deprecated Use {@linkcode TextType.FontPathOrigin.CssUrl} */
  const CssUrl = 1;
  type CssUrl = typeof CssUrl;
  /** @deprecated Use {@linkcode TextType.FontPathOrigin.ScriptUrl} */
  const ScriptUrl = 2;
  type ScriptUrl = typeof ScriptUrl;
  /** @deprecated Use {@linkcode TextType.FontPathOrigin.FontUrl} */
  const FontUrl = 3;
  type FontUrl = typeof FontUrl;
  /** @deprecated Use {@linkcode TextType.VerticalJustify.Top} */
  const VerticalJustifyTop = 0;
  type VerticalJustifyTop = typeof VerticalJustifyTop;
  /** @deprecated Use {@linkcode TextType.VerticalJustify.Center} */
  const VerticalJustifyCenter = 1;
  type VerticalJustifyCenter = typeof VerticalJustifyCenter;
  /** @deprecated Use {@linkcode TextType.VerticalJustify.Bottom} */
  const VerticalJustifyBottom = 2;
  type VerticalJustifyBottom = typeof VerticalJustifyBottom;
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Add} */
  const Add = 0;
  type Add = typeof Add;
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Subtract} */
  const Subtract = 1;
  type Subtract = typeof Subtract;
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Intersect} */
  const Intersect = 2;
  type Intersect = typeof Intersect;
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Min} */
  const Min = 3;
  type Min = typeof Min;
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Max} */
  const Max = 4;
  type Max = typeof Max;
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Difference} */
  const Difference = 5;
  type Difference = typeof Difference;
}

/**
 * How to handle multiple shapes in trim path
 */
type TrimMultipleShapes = Helpers.Values<typeof TrimMultipleShapes>;
declare namespace TrimMultipleShapes {
  type Value = TrimMultipleShapes;
  const Individually = 1;
  type Individually = typeof Individually;
  const Simultaneously = 2;
  type Simultaneously = typeof Simultaneously;
  /** @deprecated Use the {@linkcode TrimMultipleShapes} type */
  type VALUES = Helpers.Values<typeof VALUES>;
  /** @deprecated Use the {@linkcode TrimMultipleShapes} namespace */
  namespace VALUES {
    const INDIVIDUALLY = 1;
    type INDIVIDUALLY = typeof INDIVIDUALLY;
    const SIMULTANEOUSLY = 2;
    type SIMULTANEOUSLY = typeof SIMULTANEOUSLY;
  }
}

type LayerStyleType = Helpers.Values<typeof LayerStyleType>;
declare namespace LayerStyleType {
  type Value = LayerStyleType;
  const Stroke = 0;
  type Stroke = typeof Stroke;
  const DropShadow = 1;
  type DropShadow = typeof DropShadow;
  const InnerShadow = 2;
  type InnerShadow = typeof InnerShadow;
  const OuterGlow = 3;
  type OuterGlow = typeof OuterGlow;
  const InnerGlow = 4;
  type InnerGlow = typeof InnerGlow;
  const BevelEmboss = 5;
  type BevelEmboss = typeof BevelEmboss;
  const Satin = 6;
  type Satin = typeof Satin;
  const ColorOverlay = 7;
  type ColorOverlay = typeof ColorOverlay;
  const GradientOverlay = 8;
  type GradientOverlay = typeof GradientOverlay;
  /** @deprecated Use the {@linkcode LayerStyleType} type */
  type VALUE = Helpers.Values<typeof VALUE>;
  /** @deprecated Use the {@linkcode LayerStyleType} namespace */
  namespace VALUE {
    const STROKE = 0;
    type STROKE = typeof STROKE;
    const DROP_SHADOW = 1;
    type DROP_SHADOW = typeof DROP_SHADOW;
    const INNER_SHADOW = 2;
    type INNER_SHADOW = typeof INNER_SHADOW;
    const OUTER_GLOW = 3;
    type OUTER_GLOW = typeof OUTER_GLOW;
    const INNER_GLOW = 4;
    type INNER_GLOW = typeof INNER_GLOW;
    const BEVEL_EMBOSS = 5;
    type BEVEL_EMBOSS = typeof BEVEL_EMBOSS;
    const SATIN = 6;
    type SATIN = typeof SATIN;
    const COLOR_OVERLAY = 7;
    type COLOR_OVERLAY = typeof COLOR_OVERLAY;
    const GRADIENT_OVERLAY = 8;
    type GRADIENT_OVERLAY = typeof GRADIENT_OVERLAY;
  }
}

type Shape = Shape.Value;
declare namespace Shape {
  type Opacity = AnimatedProperty;
  /**
   * Base class for all elements of ShapeLayer and Group
   */
  interface Element extends Helpers.VisualObject, Helpers.PropertyIndex {
    /**
     * Whether the shape is hidden
     */
    hd?: Helpers.Hidden;
    ty: ShapeType.Value;
    bm?: BlendMode.Value;
    /**
     * Property Index
     *
     * Index used in expressions
     */
    cix?: Helpers.Index;
    /**
     * CSS Class
     *
     * CSS class used by the SVG renderer.
     */
    cl?: Helpers.CssClass;
    /**
     * Shape XML ID
     *
     * ID attribute used by the SVG renderer.
     */
    ln?: Helpers.ID;
  }
  /**
   * Drawable shape
   */
  interface Main extends Element {
    /**
     * Direction
     *
     * Direction the shape is drawn as, mostly relevant when using trim path
     */
    d?: ShapeDirection.Value;
  }
  interface Ellipse extends Main {
    ty: ShapeType.Ellipse;
    /**
     * Position
     */
    p: AnimatedProperty.Position;
    /**
     * Size
     */
    s: AnimatedProperty.MultiDimensional;
  }
  /**
   * Solid fill color
   */
  interface Fill extends Element {
    ty: ShapeType.Fill;
    o: Opacity;
    /**
     * Color
     */
    c: AnimatedProperty.Color;
    /**
     * Fill Rule
     */
    r?: FillRule.Value;
  }
  interface Gradient extends Element {
    /**
     * StartPoint
     */
    s: AnimatedProperty.MultiDimensional;
    /**
     * EndPoint
     */
    e: AnimatedProperty.MultiDimensional;
    t?: GradientType.Value;
    /**
     * Highlight Length
     */
    h?: AnimatedProperty.Value;
    /**
     * Highlight Angle
     */
    a?: AnimatedProperty.Value;
    /**
     * Colors
     */
    g: AnimatedProperty.GradientColors;
  }
  interface GradientFill extends Gradient {
    ty: ShapeType.GradientFill;
    o: Opacity;
    r?: FillRule.Value;
  }
  /**
   * An item used to described the dashe pattern in a stroked path
   */
  interface StrokeDash extends Helpers.VisualObject {
    /**
     * @default 'd'
     */
    n?: StrokeDashType.Value;
    /**
     * Length
     */
    v?: AnimatedProperty.Value;
  }
  interface BaseStroke {
    /**
     * @default 2
     */
    lc?: LineCap.Value;
    /**
     * @default 2
     */
    lj?: LineJoin.Value;
    /**
     * Miter Limit
     * @default 0
     */
    ml?: number;
    /**
     * Animatable alternative to ml
     */
    ml2?: AnimatedProperty.Value;
    o: Opacity;
    /**
     * Width
     */
    w: AnimatedProperty.Value;
    /**
     * Dashes
     */
    d?: StrokeDash[];
  }
  interface GradientStroke extends Gradient, BaseStroke {
    ty: ShapeType.GradientStroke;
  }
  /**
   * Shape Element that can contain other shapes
   */
  interface Group extends Element {
    ty: ShapeType.Group;
    /**
     * NumberOfProperties
     */
    np?: number;
    it?: Value[];
    /**
     * Property Index
     *
     * Index used in expressions
     * @type integer
     */
    cix?: number;
  }
  /**
   * Animatable Bezier curve
   */
  interface Path extends Main {
    ty: ShapeType.Path;
    /**
     * Shape
     */
    ks: AnimatedProperty.Shape;
    ind?: Helpers.Index;
  }
  interface IPolyStar extends Main {
    ty: ShapeType.PolygonStar;
    /**
     * Position
     */
    p: AnimatedProperty.Position;
    /**
     * Outer Radius
     */
    or: AnimatedProperty.Value;
    /**
     * Outer Roundness
     *
     * Outer Roundness as a percentage
     */
    os: AnimatedProperty.Value;
    /**
     * Rotation, clockwise in degrees
     */
    r: AnimatedProperty.Value;
    /**
     * Points
     */
    pt: AnimatedProperty.Value;
    /**
     * @default 1
     */
    sy?: PolyStarType.Value;
  }
  interface Polygon extends IPolyStar {
    sy: PolyStarType.Polygon;
  }
  interface Star extends IPolyStar {
    sy: PolyStarType.Star;
    /**
     * Inner Radius
     */
    ir: AnimatedProperty.Value;
    /**
     * Inner Roundness
     *
     * Inner Roundness as a percentage
     */
    is: AnimatedProperty.Value;
  }
  /**
   * Star or regular polygon
   * @if { "sy": 1 }
   * @then Star
   * @else Polygon
   */
  type PolyStar = Star | Polygon;
  /**
   * Interpolates the shape with its center point and bezier tangents with the opposite direction
   */
  interface PuckerBloat extends Element {
    ty: ShapeType.PuckerBloat;
    /**
     * Amount
     *
     * Amount as a percentage
     */
    a?: AnimatedProperty.Value;
  }
  /**
   * A simple rectangle shape
   */
  interface Rectangle extends Main {
    ty: ShapeType.Rectangle;
    /**
     * Position
     *
     * Center of the rectangle
     */
    p: AnimatedProperty.Position;
    /**
     * Size
     */
    s: AnimatedProperty.MultiDimensional;
    /**
     * Rounded
     */
    r: AnimatedProperty.Value;
  }
  interface Modifier extends Element {}
  /**
   * Transform used by a repeater, the transform is applied to each subsequent repeated object.
   */
  type RepeaterTransform = Helpers.Transform & {
    /**
     * Start Opacity
     *
     * Opacity of the first repeated object.
     */
    so?: Opacity;
    /**
     * End Opacity
     *
     * Opacity of the last repeated object.
     */
    eo?: Opacity;
  };
  /**
   * Duplicates previous shapes in a group
   */
  interface Repeater extends Modifier {
    ty: ShapeType.Repeater;
    /**
     * Copies
     */
    c: AnimatedProperty.Value;
    /**
     * Offset
     */
    o?: AnimatedProperty.Value;
    /**
     * @default 1
     */
    m?: Composite.Value;
    /**
     * Transform
     */
    tr: RepeaterTransform;
  }
  /**
   * Rounds corners of other shapes
   */
  interface RoundedCorners extends Modifier {
    ty: ShapeType.RoundedCorners;
    /**
     * Radius
     */
    r: AnimatedProperty.Value;
  }
  /**
   * Solid stroke
   */
  interface Stroke extends Element, BaseStroke {
    ty: ShapeType.Stroke;
    /**
     * Color
     */
    c: AnimatedProperty.MultiDimensional;
  }
  /**
   * Group transform
   */
  type Transform = Element &
    Helpers.Transform & {
      ty: ShapeType.Transform;
    };
  /**
   * Trims shapes into a segment
   */
  interface Trim extends Modifier {
    ty: ShapeType.Trim;
    /**
     * Start
     */
    s: AnimatedProperty.Value;
    /**
     * End
     */
    e: AnimatedProperty.Value;
    /**
     * Offset
     */
    o: AnimatedProperty.Value;
    /**
     * Multiple
     */
    m?: TrimMultipleShapes.Value;
  }
  interface Twist extends Element {
    ty: ShapeType.Twist;
    /**
     * Angle
     */
    a?: AnimatedProperty.Value;
    /**
     * Center
     */
    c?: AnimatedProperty.MultiDimensional;
  }
  interface Merge extends Element {
    ty: ShapeType.Merge;
    /**
     * Merge Mode
     * @default 1
     */
    mm?: number;
  }
  /**
   * Interpolates the shape with its center point and bezier tangents with the opposite direction
   */
  interface OffsetPath extends Element {
    ty: ShapeType.OffsetPath;
    /**
     * Amount
     */
    a?: AnimatedProperty.Value;
    /**
     * @default 2
     */
    lj?: LineJoin.Value;
    /**
     * Miter Limit
     */
    ml?: AnimatedProperty.Value;
  }
  /**
   * Changes the edges of affected shapes into a series of peaks and valleys of uniform size
   */
  interface ZigZags extends Element {
    ty: ShapeType.ZigZag;
    /**
     * Roundness
     *
     * Radius to maked it a smoother curve
     */
    r?: AnimatedProperty.Value;
    /**
     * Size
     *
     * Distance between peaks and troughs
     */
    s?: AnimatedProperty.Value;
    /**
     * Points
     *
     * Number of ridges
     */
    pt?: AnimatedProperty.Value;
  }
  /**
   * List of valid shapes (prev. Shape List)
   */
  type Value =
    | Ellipse
    | Fill
    | GradientFill
    | GradientStroke
    | Group
    | Path
    | PolyStar
    | PuckerBloat
    | Rectangle
    | Repeater
    | RoundedCorners
    | Stroke
    | Transform
    | Trim
    | Twist
    | Merge
    | OffsetPath
    | ZigZags;
}

declare namespace Text {
  /**
   * @default ""
   */
  type FontFamily = string;
  type FontSize = number;
  type FontStyle = string;
  /**
   * Defines a character as shapes
   */
  interface CharacterShapes {
    /**
     * Shape forming the character
     */
    shapes: Shape.Value[];
  }
  /**
   * Defines a character as a precomp layer
   */
  interface CharacterPrecomp {
    /**
     * Reference Id
     *
     * ID of the precomp as specified in the assets
     */
    refId: Helpers.ID;
    /**
     * Transform
     *
     * Layer transform
     */
    ks?: Helpers.Transform;
    /**
     * In Point
     *
     * Frame when the layer becomes visible
     *
     * @default 0
     */
    ip?: Helpers.InPoint;
    /**
     * Out Point
     *
     * Frame when the layer becomes invisible
     * @default 99999
     */
    op?: Helpers.OutPoint;
    /**
     * Time Stretch
     * @default 1
     */
    sr?: Helpers.Time;
    /**
     * Start Time
     *
     * @default 0
     */
    st?: Helpers.Time;
  }
  /**
   * Defines character shapes
   */
  interface CharacterData {
    data: CharacterShapes | CharacterPrecomp;
    /**
     * Character
     * @default ""
     */
    ch: string;
    /**
     * @default ""
     */
    fFamily: FontFamily;
    /**
     * @default 0
     */
    size: FontSize;
    /**
     * @default ""
     */
    style: FontStyle;
    w: Helpers.Width;
  }
  interface Font {
    /**
     * Ascent
     *
     * Text will be moved down based on this value
     */
    ascent?: number;
    /**
     * Font Family
     *
     * @default "sans"
     */
    fFamily: FontFamily;
    /**
     * Font Name
     *
     * Name used by text documents to reference this font, usually it's `fFamily` followed by `fStyle`
     * @default "sans-regular"
     */
    fName: string;
    /**
     * Font Style
     *
     * @default "Regular"
     * @example ["Regular", "Bold", "Bold Italic"]
     */
    fStyle: FontStyle;
    /**
     * Font Path
     */
    fPath?: string;
    /**
     * Font Weight
     */
    fWeight?: string;
    /**
     * Origin
     */
    origin: TextType.FontPathOrigin;
    /**
     * Font CSS Class
     *
     * CSS class applied to text objects using this font
     */
    fClass?: Helpers.CssClass;
  }
  interface FontList {
    list?: Font[];
  }
  /**
   * Uses the path described by a layer mask to put the text on said path.
   */
  interface FollowPath {
    /**
     * Mask
     *
     * Index of the mask to use
     *
     * @type integer
     */
    m?: number;
    /**
     * First Margin
     */
    f?: AnimatedProperty.Value;
    /**
     * Last Margin
     */
    l?: AnimatedProperty.Value;
    /**
     * Reverse Path
     */
    r?: AnimatedProperty.Value;
    /**
     * Force Alignment
     */
    a?: AnimatedProperty.Value;
    /**
     * Perpendicular To Path
     */
    p?: AnimatedProperty.Value;
  }
  /**
   * Text Animator Data Property
   */
  type Style = Helpers.Transform & {
    /**
     * Stroke Width
     */
    sw?: AnimatedProperty.Value;
    /**
     * Stroke Color
     */
    sc?: AnimatedProperty.Color;
    /**
     * Stroke Hue
     */
    sh?: AnimatedProperty.Value;
    /**
     * Stroke Saturation
     */
    ss?: AnimatedProperty.Value;
    /**
     * Stroke Brightness
     */
    sb?: AnimatedProperty.Value;
    /**
     * Stroke Opacity
     */
    so?: AnimatedProperty.Value;
    /**
     * Fill Color
     */
    fc?: AnimatedProperty.Color;
    /**
     * Fill Hue
     */
    fh?: AnimatedProperty.Value;
    /**
     * Fill Saturation
     */
    fs?: AnimatedProperty.Value;
    /**
     * Fill Opacity
     */
    fo?: AnimatedProperty.Value;
    /**
     * Fill Brightness
     */
    fb?: AnimatedProperty.Value;
    /**
     * Tracking
     */
    t?: AnimatedProperty.Value;
    /**
     * Blur
     */
    bl?: AnimatedProperty.Value;
    /**
     * Line Spacing
     */
    ls?: AnimatedProperty.Value;
  };
  /**
   * Animated Text Document
   * Animated property representing the text contents
   */
  interface AnimatedDocument extends Helpers.Expression {
    k: DocumentKeyframe[];
    /**
     * Slot ID
     *
     * One of the ID in the file's slots
     */
    sid?: Helpers.SlotID;
  }
  /**
   * Text Range Selector
   */
  interface Selector {
    /**
     * Expressible
     */
    t: Helpers.IntegerBoolean;
    /**
     * Max Ease
     */
    xe?: AnimatedProperty.Value;
    /**
     * Min Ease
     */
    ne?: AnimatedProperty.Value;
    /**
     * Max Amount
     */
    a: AnimatedProperty.Value;
    /**
     * Based On
     */
    b: TextType.Based;
    /**
     * Randomize
     */
    rn?: Helpers.IntegerBoolean;
    /**
     * Shape
     */
    sh: TextType.Shape;
    /**
     * Offset
     */
    o?: AnimatedProperty.Value;
    /**
     * Range Units
     *
     * @type integer
     */
    r?: number;
    /**
     * Selector Smoothness
     */
    sm?: AnimatedProperty.Value;
    /**
     * Start
     */
    s?: AnimatedProperty.Value;
    /**
     * End
     */
    e?: AnimatedProperty.Value;
  }
  /**
   * Range of text with custom animations and style
   */
  interface Range extends Helpers.Name {
    /**
     * Transform
     */
    a?: Style;
    s?: Selector;
  }
  /**
   * Text Alignment Options
   */
  interface AlignmentOptions {
    /**
     * Alignment
     *
     * Group alignment
     */
    a?: AnimatedProperty.MultiDimensional;
    /**
     * Anchor point grouping
     */
    g?: TextType.Grouping;
  }
  /**
   * Text Document
   */
  interface Document {
    /**
     * Font Family
     * @default ""
     */
    f: FontFamily;
    /**
     * Fill Color
     * @default [0,0,0]
     */
    fc: Helpers.ColorRgba;
    /**
     * Stroke Color
     */
    sc?: Helpers.ColorRgba;
    /**
     * Stroke Width
     * @default 0
     */
    sw?: number;
    /**
     * Stroke Over Fill
     * Render stroke above the fill
     */
    of?: boolean;
    /**
     * Font Size
     *
     * @default 10
     */
    s: FontSize;
    /**
     * Line Height
     *
     * Distance between lines on multiline or wrapped text
     */
    lh?: number;
    /**
     * Wrap Size
     *
     * Size of the box containing the text
     */
    sz?: [number, number];
    /**
     * Wrap Position
     *
     * Position of the box containing the text
     */
    ps?: [number, number];
    /**
     * Text
     *
     * Text, note that newlines are encoded with \\r
     * @default ''
     */
    t: string;
    /**
     * Justify
     *
     * @default 0
     */
    j?: TextType.Justify;
    /**
     * Text Caps
     */
    ca?: TextType.Caps;
    /**
     * Text Tracking
     */
    tr?: number;
    /**
     * Baseline Shift
     */
    ls?: number;
    /**
     * Vertical justification. (Skottie)
     */
    vj?: TextType.VerticalJustify;
  }
  /**
   * Text Document Keyframe
   *
   * A keyframe containing a text document
   */
  interface DocumentKeyframe {
    /**
     * Start
     */
    s: Document;
    /**
     * Start time of keyframe segment.
     *
     * @default 0
     */
    t: Helpers.Time;
  }
  /**
   * Text Data
   *
   * Animated property representing the text contents
   */
  interface Data {
    a: Range[];
    d: AnimatedDocument;
    m: AlignmentOptions;
    p: FollowPath;
  }
}

type EffectValue = EffectValue.Value;
declare namespace EffectValue {
  interface Main extends Helpers.VisualObject, Helpers.PropertyIndex {
    ty?: EffectValueType.Value;
    v?:
      | AnimatedProperty.Value
      | AnimatedProperty.Color
      | AnimatedProperty.MultiDimensional
      | number;
  }
  interface NoValue extends Main {}
  interface Angle extends Main {
    ty: EffectValueType.Angle;
    v?: AnimatedProperty.Value;
  }
  interface Checkbox extends Main {
    ty: EffectValueType.Checkbox;
    v?: AnimatedProperty.Value;
  }
  interface Color extends Main {
    ty: EffectValueType.Color;
    v?: AnimatedProperty.Color;
  }
  interface DropDown extends Main {
    ty: EffectValueType.Dropdown;
    v?: AnimatedProperty.Value;
  }
  interface IgnoredValue extends Main {
    ty: EffectValueType.Ignored;
    v?: number;
  }
  interface Layer extends Main {
    ty: EffectValueType.Layer;
    v?: AnimatedProperty.Value;
  }
  interface Point extends Main {
    ty: EffectValueType.Point;
    v?: AnimatedProperty.MultiDimensional;
  }
  interface Slider extends Main {
    ty: EffectValueType.Slider;
    v?: AnimatedProperty.Value;
  }
  type Value =
    | NoValue
    | Angle
    | Checkbox
    | Color
    | DropDown
    | IgnoredValue
    | Layer
    | Point
    | Slider;
}

type Effect = Effect.Value;
declare namespace Effect {
  interface Main extends Helpers.VisualObject, Helpers.PropertyIndex {
    /** Effect Parameters */
    ef: EffectValue.Value[];
    ty: EffectType.Value;
    /** Enabled */
    en?: Helpers.IntegerBoolean;
    /**
     * NumberOfProperties
     */
    np?: number;
  }
  /**
   * Adds a shadow to the layer
   */
  interface DisplacementMap extends Main {
    ty: EffectType.DisplacementMap;
    ef: [
      /** Displacement Map Layer */
      EffectValue.Layer,
      /** Use For Horizontal Displacement */
      EffectValue.DropDown,
      /** Max Horizontal Displacement */
      EffectValue.Slider,
      /** Use For Vertical Displacement */
      EffectValue.DropDown,
      /** Max Vertical Displacement */
      EffectValue.Slider,
      /** Displacement Map Behavior */
      EffectValue.DropDown,
      /** Edge Behavior */
      EffectValue.DropDown,
      /** Expand Output */
      EffectValue.DropDown,
    ];
  }
  interface DropShadow extends Main {
    ty: EffectType.DropShadow;
    ef: [
      /** Color */
      EffectValue.Color,
      /** Opacity between 0 and 255 */
      EffectValue.Slider,
      /** Angle */
      EffectValue.Angle,
      /** Distance */
      EffectValue.Slider,
      /** Blur */
      EffectValue.Slider,
    ];
  }
  /**
   * Replaces the whole layer with the given color
   *
   * Opacity is in [0, 1]
   */
  interface Fill extends Main {
    ty: EffectType.Fill;
    ef: [
      /** 00 */
      EffectValue.Point,
      /** 01 */
      EffectValue.DropDown,
      /** Color */
      EffectValue.Color,
      /** Color */
      EffectValue.Color,
      /** 03 */
      EffectValue.DropDown,
      /** 04 */
      EffectValue.Slider,
      /** 05 */
      EffectValue.Slider,
      /** Opacity in [0, 1] */
      EffectValue.Slider,
    ];
  }
  /**
   * Gaussian blur
   */
  interface GaussianBlur extends Main {
    ty: EffectType.GaussianBlur;
    ef: [
      /** Sigma */
      EffectValue.Slider,
      /** Dimensions */
      EffectValue.Slider,
      /** Wrap */
      EffectValue.Checkbox,
    ];
  }
  interface Matte3 extends Main {
    ty: EffectType.Matte3;
    ef: [
      /** Index */
      EffectValue.Slider,
    ];
  }
  interface MeshWarp extends Main {
    ty: EffectType.MeshWarp;
    ef: [
      /** Rows */
      EffectValue.Slider,
      /** Columns */
      EffectValue.Slider,
      /** Quality */
      EffectValue.Slider,
      /** 03 */
      EffectValue.NoValue,
    ];
  }
  interface PaintOverTransparent extends Main {
    ty: EffectType.PaintOverTransparent;
    ef: [
      /** 00 */
      EffectValue.Slider,
    ];
  }
  interface ProLevels extends Main {
    ty: EffectType.ProLevels;
    ef: [
      /** 00 */
      EffectValue.DropDown,
      /** 01 */
      EffectValue.NoValue,
      /** 02 */
      EffectValue.NoValue,
      /** comp_inblack */
      EffectValue.Slider,
      /** comp_inwhite */
      EffectValue.Slider,
      /** comp_gamma */
      EffectValue.Slider,
      /** comp_outblack */
      EffectValue.NoValue,
      /** comp_outwhite */
      EffectValue.NoValue,
      /** 08 */
      EffectValue.NoValue,
      /** 09 */
      EffectValue.Slider,
      /** r_inblack */
      EffectValue.Slider,
      /** r_inwhite */
      EffectValue.Slider,
      /** r_gamma */
      EffectValue.Slider,
      /** r_outblack */
      EffectValue.Slider,
      /** r_outwhite */
      EffectValue.Slider,
      /** 15 */
      EffectValue.Slider,
      /** 16 */
      EffectValue.Slider,
      /** g_inblack */
      EffectValue.Slider,
      /** g_inwhite */
      EffectValue.Slider,
      /** g_gamma */
      EffectValue.Slider,
      /** g_outblack */
      EffectValue.Slider,
      /** g_outwhite */
      EffectValue.Slider,
      /** 22 */
      EffectValue.Slider,
      /** 23 */
      EffectValue.Slider,
      /** b_inblack */
      EffectValue.Slider,
      /** b_inwhite */
      EffectValue.Slider,
      /** b_gamma */
      EffectValue.Slider,
      /** b_outblack */
      EffectValue.Slider,
      /** b_outwhite */
      EffectValue.Slider,
      /** 29 */
      EffectValue.Slider,
      /** a_inblack */
      EffectValue.Slider,
      /** a_inwhite */
      EffectValue.Slider,
      /** g_gamma */
      EffectValue.Slider,
      /** a_outblack */
      EffectValue.Slider,
      /** a_outwhite */
      EffectValue.Slider,
    ];
  }
  interface Puppet extends Main {
    ty: EffectType.Puppet;
    ef: [
      /** Puppet Engine */
      EffectValue.DropDown,
      /** Mesh Rotation Refinement */
      EffectValue.Slider,
      /** On Transparent */
      EffectValue.DropDown,
      /** 03 */
      EffectValue.NoValue,
    ];
  }
  interface RadialWipe extends Main {
    ty: EffectType.RadialWipe;
    ef: [
      /** Completion. Between 0 and 100 */
      EffectValue.Slider,
      /** Start Angle */
      EffectValue.Angle,
      /** Wipe Center */
      EffectValue.Point,
      /** Wipe */
      EffectValue.Slider,
      /** Feather */
      EffectValue.Slider,
    ];
  }
  interface Spherize extends Main {
    ty: EffectType.Spherize;
    ef: [
      /** Radius */
      EffectValue.Slider,
      /** Center */
      EffectValue.Point,
    ];
  }
  interface Stroke extends Main {
    ty: EffectType.Stroke;
    ef: [
      /** 00 */
      EffectValue.Color,
      /** 01 */
      EffectValue.Checkbox,
      /** 02 */
      EffectValue.Checkbox,
      /** Color */
      EffectValue.Color,
      /** 04 */
      EffectValue.Slider,
      /** 05 */
      EffectValue.Slider,
      /** 06 */
      EffectValue.Slider,
      /** 07 */
      EffectValue.Slider,
      /** 08 */
      EffectValue.Slider,
      /** 09 */
      EffectValue.DropDown,
      /** type */
      EffectValue.DropDown,
    ];
  }
  /**
   * Colorizes the layer
   *
   * Opacity in [0, 100]
   */
  interface Tint extends Main {
    ty: EffectType.Tint;
    ef: [
      /**
       * Black Color.
       *
       * Tint of the darker parts of the layer.
       */
      EffectValue.Color,
      /**
       * White Color
       *
       * Tint of the lighter parts of the layer
       */
      EffectValue.Color,
      /**
       * Intensity
       *
       * Intensity of the effect, 0 means the layer is unchanged. 100 means full effect.
       */
      EffectValue.Slider,
    ];
  }
  /**
   * Maps layers colors based on bright/mid/dark colors
   */
  interface Tritone extends Main {
    ty: EffectType.Tritone;
    ef: [
      /** Bright */
      EffectValue.Color,
      /** Mid */
      EffectValue.Color,
      /** Dark */
      EffectValue.Color,
    ];
  }
  interface Wavy extends Main {
    ty: EffectType.Wavy;
    ef: [
      /** Radius */
      EffectValue.Slider,
      /** Center */
      EffectValue.Point,
      /** Conversion Type */
      EffectValue.DropDown,
      /** Speed */
      EffectValue.DropDown,
      /** Width */
      EffectValue.Slider,
      /** Height */
      EffectValue.Slider,
      /** Phase */
      EffectValue.Slider,
    ];
  }
  /**
   * Some lottie files use `ty` = 5 for many different effects
   */
  interface Custom extends Main {
    ty: EffectType.Custom;
  }
  /**
   * Layer Effect
   */
  type Value =
    | Custom
    | DropShadow
    | Fill
    | GaussianBlur
    | Matte3
    | ProLevels
    | Stroke
    | Tint
    | Tritone
    | RadialWipe
    | Wavy
    | Puppet
    | Spherize
    | PaintOverTransparent
    | MeshWarp
    | DisplacementMap;
}

type Style = Style.Value;
declare namespace Style {
  type OpacityValue = AnimatedProperty.Value;
  type ColorValue = AnimatedProperty.Color;
  type AngleValue = AnimatedProperty.Value;
  interface ChokeSpread {
    ch?: AnimatedProperty.Value;
  }
  interface BlendMode {
    bm?: AnimatedProperty.Value;
  }
  interface Opacity {
    o?: OpacityValue;
  }
  /**
   * Size or Blur Size
   */
  interface Size {
    s?: AnimatedProperty.Value;
  }
  interface Noise {
    no?: AnimatedProperty.Value;
  }
  interface Distance {
    d?: AnimatedProperty.Value;
  }
  interface Color {
    c?: ColorValue;
  }
  /**
   * Local light angle
   */
  interface Angle {
    a?: AngleValue;
  }
  /**
   * Layer Style
   *
   * Style applied to a layer
   */
  interface Layer extends Helpers.VisualObject {
    /**
     * Type
     *
     * Style Type
     * @type integer
     */
    ty: LayerStyleType.Value;
  }
  interface Stroke extends Layer, Size, Color {
    ty: LayerStyleType.Stroke;
  }
  interface DropShadow
    extends Layer,
      Color,
      Opacity,
      Angle,
      Size,
      Distance,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.DropShadow;
    /**
     * Layer Conceal
     *
     * Layer knowck out drop shadow
     */
    lc?: AnimatedProperty.Value;
  }
  interface InnerShadow
    extends Layer,
      Color,
      Opacity,
      Angle,
      Size,
      Distance,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.InnerShadow;
  }
  interface OuterGlow
    extends Layer,
      Color,
      Opacity,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.OuterGlow;
    /**
     * Range
     */
    r?: AnimatedProperty.Value;
    /**
     * Jitter
     */
    j?: AnimatedProperty.Value;
  }
  interface InnerGlow extends Omit<OuterGlow, "ty"> {
    ty: LayerStyleType.InnerGlow;
    /**
     * Source
     */
    sr?: AnimatedProperty.Value;
  }
  interface BevelEmboss extends Layer, Size, Angle {
    ty: LayerStyleType.BevelEmboss;
    /**
     * Bevel Style
     */
    bs?: AnimatedProperty.Value;
    /**
     * Technique
     */
    bt?: AnimatedProperty.Value;
    /**
     * Strength
     */
    sr?: AnimatedProperty.Value;
    /**
     * Soften
     */
    sf?: AnimatedProperty.Value;
    /**
     * Global Angle
     *
     * Use global light
     */
    ga?: AngleValue;
    /**
     * Altitude
     *
     * Local lighting altitude
     */
    ll?: AnimatedProperty.Value;
    /**
     * Highlight Mode
     */
    hm?: AnimatedProperty.Value;
    /**
     * Highlight Color
     */
    hc?: ColorValue;
    /**
     * Highlight Opacity
     */
    ho?: OpacityValue;
    /**
     * Shadow Mode
     */
    sm?: AnimatedProperty.Value;
    /**
     * Shadow Color
     */
    sc?: ColorValue;
    /**
     * Shadow Opacity
     */
    so?: OpacityValue;
  }
  interface Satin
    extends Layer,
      BlendMode,
      Color,
      Opacity,
      Angle,
      Distance,
      Size {
    ty: LayerStyleType.Satin;
    /**
     * Invert
     */
    in?: AnimatedProperty.Value;
  }
  interface ColorOverlay extends Layer, BlendMode, Color {
    ty: LayerStyleType.ColorOverlay;
    /**
     * Opacity
     */
    so?: OpacityValue;
  }
  interface GradientOverlay extends Layer, BlendMode, Opacity, Angle {
    ty: LayerStyleType.GradientOverlay;
    /**
     * Gradient
     */
    gf?: AnimatedProperty.GradientColors;
    /**
     * Smoothness
     */
    gs?: AnimatedProperty.Value;
    /**
     * Gradient Type
     */
    gt?: GradientType.Value;
    /**
     * Reverse
     */
    re?: AnimatedProperty.Value;
    /**
     * Align
     *
     * Align with layer
     */
    al?: AnimatedProperty.Value;
    /**
     * Scale
     */
    s?: AnimatedProperty.Value;
    /**
     * Offset
     */
    of?: AnimatedProperty.Value;
  }
  type Value =
    | Stroke
    | DropShadow
    | InnerShadow
    | OuterGlow
    | InnerGlow
    | BevelEmboss
    | Satin
    | ColorOverlay
    | GradientOverlay;
}

type Layer = Layer.Value;
declare namespace Layer {
  interface Main extends Helpers.VisualObject, Helpers.Threedimensional {
    /**
     * Whether the layer is hidden
     */
    hd?: Helpers.Hidden;
    ty: LayerType.Value;
    /**
     * Index that can be used for parenting and referenced in expressions
     * @type integer
     */
    ind?: Helpers.Index;
    /**
     * Parent Index
     *
     * Must be the `ind` property of another Layer
     */
    parent?: number;
    /**
     * Time Stretch
     */
    sr?: Helpers.Time;
    /**
     * In Point - Frame when the layer becomes visible
     */
    ip: Helpers.InPoint;
    /**
     * Out Point - Frame when the layer becomes invisible
     */
    op: Helpers.OutPoint;
    /**
     * Start Time
     */
    st?: Helpers.Time;
  }
  interface AudioSettings {
    /**
     * Level
     */
    lv: AnimatedProperty.MultiDimensional;
  }
  /**
   * A layer playing sounds
   */
  interface Audio extends Main {
    ty: LayerType.Audio;
    au: AudioSettings;
    /**
     * Sound Id
     *
     * ID of the sound as specified in the assets.
     */
    refId?: Helpers.ID;
  }
  /**
   * Layer used to affect visual elements
   */
  interface Visual extends Main {
    /**
     * Collapse Transform
     *
     * This is deprecated in favour of "ct"
     * @deprecated true
     */
    cp?: boolean;
    /**
     * Layer Transform
     */
    ks: Helpers.Transform;
    /**
     * AutoOrient
     *
     * If 1, The layer will rotate itself to match its animated position path
     * @default 0
     */
    ao?: Helpers.IntegerBoolean;
    /**
     * Matte mode, the layer will inherit the transparency from the layer above
     * */
    tt?: MatteMode.Value;
    /**
     * Matte parent
     *
     * Index of the layer used as matte, if omitted assume the layer above the current one
     *
     * "type": "integer"
     */
    tp?: number;
    /**
     * Matte Target
     */
    td?: number;
    /**
     * Whether the layer has masks applied
     */
    hasMask?: boolean;
    /** List of Masks */
    masksProperties?: Helpers.Mask[];
    /**
     * List of Effects
     */
    ef?: Effect.Value[];
    /**
     * Motion Blur
     *
     * Whether motion blur is enabled for the layer
     */
    mb?: boolean;
    /**
     * Layer Style
     *
     * Styling effects for this layer
     */
    sy?: Style.Value[];
    /**
     * Collapse Transform
     *
     * Marks that transforms should be applied before masks
     * @default 0
     */
    ct?: Helpers.IntegerBoolean;
    /**
     * Blend Mode
     * @default 0
     */
    bm?: BlendMode.Value;
    /**
     * CSS class used by the SVG renderer
     */
    cl?: Helpers.CssClass;
    /**
     * Layer XML ID
     *
     * ID attribute used by the SVG renderer
     */
    ln?: Helpers.ID;
    /**
     * Layer XML tag name
     *
     * tag name used by the SVG renderer
     */
    tg?: string;
  }
  /**
   * Layer that renders a Precomposition asset
   */
  interface Precomposition extends Visual {
    ty: LayerType.Precomposition;
    /**
     * Reference ID
     *
     * ID of the precomp as specified in the assets
     */
    refId: Helpers.ID;
    /**
     * Width of the clipping rect
     */
    w: Helpers.Width;
    /**
     * Height of the clipping rect
     */
    h: Helpers.Height;
    /**
     * Time Remapping
     */
    tm?: AnimatedProperty.Value;
  }
  /**
   * Layer containing Shapes
   */
  interface Shape extends Visual {
    ty: LayerType.Shape;
    shapes: Shape.Value[];
  }
  /**
   * Layer with a solid color rectangle
   */
  interface SolidColor extends Visual {
    ty: LayerType.SolidColor;
    /**
     * Color
     *
     * Color of the layer, unlike most other places, the color is a `#rrggbb` hex string
     */
    sc: string;
    /**
     * @default 512
     */
    sh: Helpers.Height;
    /**
     * @default 512
     */
    sw: Helpers.Width;
  }
  /**
   * Layer that shows an image asset
   */
  interface Image extends Visual {
    ty: LayerType.Image;
    /**
     * Image ID
     *
     * ID of the image as specified in the assets
     * @default ""
     */
    refId: Helpers.ID;
  }
  /**
   * Layer with no data, useful to group layers together
   */
  interface Null extends Visual {
    ty: LayerType.Null;
  }
  /**
   * Layer with some text
   */
  interface Text extends Visual {
    ty: LayerType.Text;
    /**
     * Data
     */
    t: Text.Data;
  }
  interface Camera extends Main {
    ty: LayerType.Camera;
    /**
     * Perspective
     *
     * Distance from the Z=0 plane.\nSmall values yield a higher perspective effect.
     */
    pe: AnimatedProperty.Value;
    ks: Helpers.Transform;
  }
  interface Data extends Main {
    ty: LayerType.Data;
    /**
     * Data source ID
     *
     * ID of the data source in assets
     */
    refId?: Helpers.ID;
  }
  interface VideoPlaceholder extends Main {
    ty: LayerType.VideoPlaceholder;
  }
  interface ImageSequence extends Main {
    ty: LayerType.ImageSequence;
  }
  interface Video extends Main {
    ty: LayerType.Video;
  }
  interface ImagePlaceholder extends Main {
    ty: LayerType.ImagePlaceholder;
  }
  interface Guide extends Main {
    ty: LayerType.Guide;
  }
  interface Adjustment extends Main {
    ty: LayerType.Adjustment;
  }
  interface Light extends Main {
    ty: LayerType.Light;
  }
  type Value =
    | Audio
    | Precomposition
    | SolidColor
    | Image
    | Null
    | Shape
    | Text
    | Camera
    | VideoPlaceholder
    | Data
    | ImageSequence
    | Video
    | ImagePlaceholder
    | Guide
    | Adjustment
    | Light;
}

/**
 * Defines named portions of the composition.
 */
type Marker = {
  /**
   * Comment
   */
  cm?: string;
  tm?: Helpers.Time;
  /**
   * Duration
   */
  dr?: number;
};
/**
 * Defines property / image asset overrides.
 */
type Slot = {
  /**
   * Slot Property
   */
  p:
    | AnimatedProperty.MultiDimensional
    | AnimatedProperty.Color
    | AnimatedProperty.Position
    | AnimatedProperty.Shape
    | AnimatedProperty.Value
    | Text.AnimatedDocument
    | Asset.Image;
};
/**
 * Base class for layer holders
 */
interface Composition {
  layers: Layer.Value[];
}
/**
 * Document metadata
 */
interface Metadata {
  /**
   * Author
   */
  a?: string;
  /**
   * Keywords
   */
  k?: string | string[];
  /**
   * Description
   */
  d?: string;
  /**
   * ThemeColor
   */
  tc?: string;
  /**
   * Generator
   *
   * Software used to generate the file
   */
  g?: string;
}
/**
 * Motion blur settings
 */
interface MotionBlur {
  /**
   * Shutter Angle
   *
   * Angle in degrees
   * AE default: 180
   * Skottie default: O ([0, 720])
   */
  sa?: number;
  /**
   * Shutter Phase
   *
   * Angle in degrees
   * AE default: -90
   * Skottie default: 0 ([-360, 360])
   */
  sp?: number;
  /**
   * Samples Per Frame
   * AE default: 16
   * Skottie default: 1 ([1, 64])
   */
  spf?: number;
  /**
   * Adaptive Sample Limit
   *
   * (not yet supported in any known Lottie player)
   * AE default: 128
   * 2D layer motion automatically uses more samples per frame
   * when needed, up to the value specified by Adaptive Sample Limit.
   */
  asl?: number;
}
/**
 * Top level object, describing the animation
 */
interface Animation
  extends Helpers.VisualObject,
    Helpers.Threedimensional,
    Helpers.Framerate,
    Composition {
  /**
   * Version
   * @default 5.5.2
   */
  v?: string;
  /**
   * "In Point", which frame the animation starts at (usually 0)
   * @default 0
   */
  ip: Helpers.InPoint;
  /**
   * "Out Point", which frame the animation stops/loops at, which makes this the duration in frames when `ip` is 0
   * @default 60
   */
  op: Helpers.OutPoint;
  /**
   * Width of the animation
   * @default 512
   */
  w: Helpers.Width;
  /**
   * Height of the animation
   * @default 512
   */
  h: Helpers.Height;
  /**
   * List of assets that can be referenced by layers
   */
  assets?: Asset.Value[];
  /**
   * Extra Compositions
   *
   * List of Extra compositions not referenced by anything
   */
  comps?: Asset.Precomposition[];
  fonts?: Text.FontList;
  /**
   * Data defining text characters as lottie shapes. If present a player
   * might only render characters defined here and nothing else.
   */
  chars?: Text.CharacterData[];
  meta?: Metadata;
  /**
   * User Metadata
   *
   * User-defined metadata
   */
  metadata?: object;
  /**
   * Markers defining named sections of the composition.
   */
  markers?: Marker[];
  mb?: MotionBlur;
  /**
   * Available property overrides
   */
  slots?: {
    [key: Helpers.SlotID]: Slot;
  };
}

type Asset = Asset.Value;
declare namespace Asset {
  interface Main extends Helpers.Name {
    /**
     * ID
     *
     * Unique identifier used by layers when referencing this asset
     * @default ""
     */
    id: string;
  }
  /**
   * Asset referencing a file
   */
  interface File extends Main {
    /**
     * Path
     *
     * Path to the directory containing an asset file
     * @default ""
     */
    u?: string;
    /**
     * Filename or Data URL
     */
    p: string;
    /**
     * Embedded
     *
     * Whether the asset is embedded
     * @default 0
     */
    e?: Helpers.IntegerBoolean;
  }
  /**
   * External image
   */
  interface Image extends File {
    /**
     * Width of the image
     * @default 0
     */
    w?: Helpers.Width;
    /**
     *
     * Height of the image
     * @default 0
     */
    h?: Helpers.Height;
    /**
     * Type
     * Marks as part of an image sequence if present
     */
    t?: "seq";
    /**
     * Slot ID
     *
     * One of the ID in the file's slots
     */
    sid?: Helpers.SlotID;
  }
  /**
   * External sound
   */
  interface Sound extends File {}
  /**
   * Asset containing an animation that can be referenced by layers.
   */
  interface Precomposition extends Main, Composition, Helpers.Framerate {
    /**
     * Extra
     *
     * Extra composition
     * @default 0
     */
    xt?: Helpers.IntegerBoolean;
  }
  /**
   * External data source, usually a JSON file"
   */
  interface DataSource extends File {
    /**
     * Type
     * @type integer
     */
    t: 3;
  }
  type Value = Image | Precomposition | Sound | DataSource;
}

export {
  AnimatedProperty,
  Asset,
  BlendMode,
  Composite,
  Effect,
  EffectType,
  EffectValue,
  EffectValueType,
  FillRule,
  GradientType,
  Helpers,
  Layer,
  LayerStyleType,
  LayerType,
  LineCap,
  LineJoin,
  MaskMode,
  MatteMode,
  PolyStarType,
  Shape,
  ShapeDirection,
  ShapeType,
  StrokeDashType,
  Style,
  Text,
  TextType,
  TrimMultipleShapes,
};
export type { Animation, Composition, Marker, Metadata, MotionBlur, Slot };
