/*!
 * @lottie-animation-community/lottie-types - v1.2.0
 * Compiled Sun, 30 Mar 2025 07:08:23 UTC
 *
 * Generated by an automated process. DO NOT EDIT!
 *
 * Copyright 2022 Lottie Animation Community.
 *
 * Licensed under the MIT License,
 * You may obtain a copy of the License at:
 * https://github.com/lottie-animation-community/lottie-types/blob/main/LICENSE
 *
 * Type definitions for the Lottie animation format.
 * Definitions by: Aidos Sabit <https://github.com/aidosmf>.
 *
 * To report an issue with these types, please open a support ticket at:
 * https://github.com/lottie-animation-community/lottie-types/issues
 */
/**
 * Layer and shape blend mode
 */
declare enum BlendMode {
  Normal = 0,
  Multiply = 1,
  Screen = 2,
  Overlay = 3,
  Darken = 4,
  Lighten = 5,
  ColorDodge = 6,
  ColorBurn = 7,
  HardLight = 8,
  SoftLight = 9,
  Difference = 10,
  Exclusion = 11,
  Hue = 12,
  Saturation = 13,
  Color = 14,
  Luminosity = 15,
  Add = 16,
  HardMix = 17,
}
declare namespace BlendMode {
  type Value = BlendMode;

  /** @deprecated Use the {@linkcode BlendMode} enum */
  const enum VALUE {
    NORMAL = BlendMode.Normal,
    MULTIPLY = BlendMode.Multiply,
    SCREEN = BlendMode.Screen,
    OVERLAY = BlendMode.Overlay,
    DARKEN = BlendMode.Darken,
    LIGHTEN = BlendMode.Lighten,
    COLOR_DODGE = BlendMode.ColorDodge,
    COLOR_BURN = BlendMode.ColorBurn,
    HARD_LIGHT = BlendMode.HardLight,
    SOFT_LIGHT = BlendMode.SoftLight,
    DIFFERENCE = BlendMode.Difference,
    EXCLUSION = BlendMode.Exclusion,
    HUE = BlendMode.Hue,
    SATURATION = BlendMode.Saturation,
    COLOR = BlendMode.Color,
    LUMINOSITY = BlendMode.Luminosity,
    ADD = BlendMode.Add,
    HARD_MIX = BlendMode.HardMix,
  }
}

/**
 * How to stack copies in a repeater
 */
declare enum Composite {
  Above = 1,
  Below = 2,
}
declare namespace Composite {
  type Value = Composite;

  /** @deprecated Use the {@linkcode Composite} enum */
  const enum VALUE {
    ABOVE = Composite.Above,
    BELOW = Composite.Below,
  }
}

declare enum EffectValueType {
  Slider = 0,
  Angle = 1,
  Color = 2,
  Point = 3,
  Checkbox = 4,
  Ignored = 6,
  Dropdown = 7,
  Layer = 10,
}

declare namespace EffectValueType {
  type Value = EffectValueType;

  /** @deprecated Use the {@linkcode EffectValueType} enum */
  const enum VALUE {
    SLIDER = EffectValueType.Slider,
    ANGLE = EffectValueType.Angle,
    COLOR = EffectValueType.Color,
    POINT = EffectValueType.Point,
    CHECKBOX = EffectValueType.Checkbox,
    IGNORED = EffectValueType.Ignored,
    DROPDOWN = EffectValueType.Dropdown,
    LAYER = EffectValueType.Layer,
  }
}

declare enum EffectType {
  Custom = 5,
  PaintOverTransparent = 7,
  Tint = 20,
  Fill = 21,
  Stroke = 22,
  Tritone = 23,
  ProLevels = 24,
  DropShadow = 25,
  RadialWipe = 26,
  DisplacementMap = 27,
  Matte3 = 28,
  GaussianBlur = 29,
  MeshWarp = 31,
  Wavy = 32,
  Spherize = 33,
  Puppet = 34,
}
declare namespace EffectType {
  type Value = EffectType;

  /** @deprecated Use the {@linkcode EffectType} enum */
  const enum VALUE {
    CUSTOM = EffectType.Custom,
    PAINT_OVER_TRANSPARENT = EffectType.PaintOverTransparent,
    TINT = EffectType.Tint,
    FILL = EffectType.Fill,
    STROKE = EffectType.Stroke,
    TRITONE = EffectType.Tritone,
    PRO_LEVELS = EffectType.ProLevels,
    DROP_SHADOW = EffectType.DropShadow,
    RADIAL_WIPE = EffectType.RadialWipe,
    DISPLACEMENT_MAP = EffectType.DisplacementMap,
    MATTE3 = EffectType.Matte3,
    GAUSSIAN_BLUR = EffectType.GaussianBlur,
    MESH_WARP = EffectType.MeshWarp,
    WAVY = EffectType.Wavy,
    SPHERIZE = EffectType.Spherize,
    PUPPET = EffectType.Puppet,
  }
}

/**
 * Rule used to handle multiple shapes rendered with the same fill object
 */
declare enum FillRule {
  NonZero = 1,
  EvenOdd = 2,
}

declare namespace FillRule {
  type Value = FillRule;

  /** @deprecated Use the {@linkcode FillRule} enum */
  const enum VALUE {
    NON_ZERO = FillRule.NonZero,
    EVEN_ODD = FillRule.EvenOdd,
  }
}

/**
 * Type of a gradient
 *
 * @default 1
 */
declare enum GradientType {
  Linear = 1,
  Radial = 2,
}

declare namespace GradientType {
  type Value = GradientType;

  /** @deprecated Use the {@linkcode GradientType} enum */
  const enum VALUE {
    LINEAR = GradientType.Linear,
    RADIAL = GradientType.Radial,
  }
}

declare enum LayerType {
  Precomposition = 0,
  SolidColor = 1,
  Image = 2,
  Null = 3,
  Shape = 4,
  Text = 5,
  Audio = 6,
  VideoPlaceholder = 7,
  ImageSequence = 8,
  Video = 9,
  ImagePlaceholder = 10,
  Guide = 11,
  Adjustment = 12,
  Camera = 13,
  Light = 14,
  Data = 15,
}

declare namespace LayerType {
  type Value = LayerType;

  /** @deprecated Use the {@linkcode LayerType} enum */
  const enum VALUE {
    PRECOMPOSITION = LayerType.Precomposition,
    SOLID_COLOR = LayerType.SolidColor,
    IMAGE = LayerType.Image,
    NULL = LayerType.Null,
    SHAPE = LayerType.Shape,
    TEXT = LayerType.Text,
    AUDIO = LayerType.Audio,
    VIDEO_PLACEHOLDER = LayerType.VideoPlaceholder,
    IMAGE_SEQUENCE = LayerType.ImageSequence,
    VIDEO = LayerType.Video,
    IMAGE_PLACEHOLDER = LayerType.ImagePlaceholder,
    GUIDE = LayerType.Guide,
    ADJUSTMENT = LayerType.Adjustment,
    CAMERA = LayerType.Camera,
    LIGHT = LayerType.Light,
    DATA = LayerType.Data,
  }
}

/**
 * Style at the end of a stoked line
 */
declare enum LineCap {
  Butt = 1,
  Round = 2,
  Square = 3,
}
declare namespace LineCap {
  type Value = LineCap;

  /** @deprecated Use the {@linkcode LineCap} enum */
  const enum VALUE {
    BUTT = LineCap.Butt,
    ROUND = LineCap.Round,
    SQUARE = LineCap.Square,
  }
}

/**
 * Style at a sharp corner of a stoked line
 */
declare enum LineJoin {
  Miter = 1,
  Round = 2,
  Bevel = 3,
}
declare namespace LineJoin {
  type Value = LineJoin;

  /** @deprecated Use the {@linkcode LineJoin} enum */
  const enum VALUE {
    MITER = LineJoin.Miter,
    ROUND = LineJoin.Round,
    BEVEL = LineJoin.Bevel,
  }
}

/**
 * How masks interact with each other. See https://helpx.adobe.com/after-effects/using/alpha-channels-masks-mattes.html
 */
declare enum MaskMode {
  No = "n",
  Add = "a",
  Subtract = "s",
  Intersect = "i",
  Lighten = "l",
  Darken = "d",
  Difference = "f",
}
declare namespace MaskMode {
  type Value = MaskMode;

  /** @deprecated Use the {@linkcode MaskMode} enum */
  const enum VALUE {
    NO = MaskMode.No,
    ADD = MaskMode.Add,
    SUBTRACT = MaskMode.Subtract,
    INTERSECT = MaskMode.Intersect,
    LIGHTEN = MaskMode.Lighten,
    DARKEN = MaskMode.Darken,
    DIFFERENCE = MaskMode.Difference,
  }
}

/**
 * How a layer should mask another layer
 */
declare enum MatteMode {
  Normal = 0,
  Alpha = 1,
  InvertedAlpha = 2,
  Luma = 3,
  InvertedLuma = 4,
}
declare namespace MatteMode {
  type Value = MatteMode;

  /** @deprecated Use the {@linkcode MatteMode} enum */
  const enum VALUE {
    NORMAL = MatteMode.Normal,
    ALPHA = MatteMode.Alpha,
    INVERTED_ALPHA = MatteMode.InvertedAlpha,
    LUMA = MatteMode.Luma,
    INVERTED_LUMA = MatteMode.InvertedLuma,
  }
}

/**
 * Star type, `1` for Star, `2` for Polygon
 */
declare enum PolyStarType {
  Star = 1,
  Polygon = 2,
}
declare namespace PolyStarType {
  type Value = PolyStarType;

  /** @deprecated Use the {@linkcode PolyStarType} enum */
  const enum VALUE {
    STAR = PolyStarType.Star,
    POLYGON = PolyStarType.Polygon,
  }
}

/**
 * Drawing direction of the shape curve, useful for trim path
 */
declare enum ShapeDirection {
  /**
   * Default Clockwise
   */
  Normal = 0,

  /**
   * Usually clockwise
   */
  Clockwise = 1,

  /**
   * Usually counter clockwise
   */
  ClockwiseReversed = 3,
}
declare namespace ShapeDirection {
  type Value = ShapeDirection;

  /** @deprecated Use the {@linkcode ShapeDirection} enum */
  const enum VALUE {
    NORMAL = ShapeDirection.Normal,
    CLOCKWISE = ShapeDirection.Clockwise,
    CLOCKWISE_REVERSED = ShapeDirection.ClockwiseReversed,
  }
}

declare enum ShapeType {
  Rectangle = "rc",
  Ellipse = "el",
  PolygonStar = "sr",
  Path = "sh",
  Fill = "fl",
  Stroke = "st",
  GradientFill = "gf",
  GradientStroke = "gs",
  Group = "gr",
  Transform = "tr",
  RoundedCorners = "rd",
  PuckerBloat = "pb",
  Merge = "mm",
  Twist = "tw",
  OffsetPath = "op",
  ZigZag = "zz",
  Modifier = "", // null
  Repeater = "rp",
  Trim = "tm",
}
declare namespace ShapeType {
  type Value = ShapeType;

  /** @deprecated Use the {@linkcode ShapeType} enum */
  const enum VALUE {
    RECTANGLE = ShapeType.Rectangle,
    ELLIPSE = ShapeType.Ellipse,
    POLYGON_STAR = ShapeType.PolygonStar,
    PATH = ShapeType.Path,
    FILL = ShapeType.Fill,
    STROKE = ShapeType.Stroke,
    GRADIENT_FILL = ShapeType.GradientFill,
    GRADIENT_STROKE = ShapeType.GradientStroke,
    GROUP = ShapeType.Group,
    TRANSFORM = ShapeType.Transform,
    ROUNDED_CORNERS = ShapeType.RoundedCorners,
    PUCKER_BLOAT = ShapeType.PuckerBloat,
    MERGE = ShapeType.Merge,
    TWIST = ShapeType.Twist,
    OFFSET_PATH = ShapeType.OffsetPath,
    ZIG_ZAG = ShapeType.ZigZag,
    MODIFIER = ShapeType.Modifier,
    REPEATER = ShapeType.Repeater,
    TRIM = ShapeType.Trim,
  }
}

/**
 * Type of a dash item in a stroked line
 */
declare enum StrokeDashType {
  Default = "d",
  Gap = "g",
  Offset = "o",
}
declare namespace StrokeDashType {
  type Value = StrokeDashType;

  /** @deprecated Use the {@linkcode StrokeDashType} enum */
  const enum VALUE {
    DEFAULT = StrokeDashType.Default,
    GAP = StrokeDashType.Gap,
    OFFSET = StrokeDashType.Offset,
  }
}

declare enum TextType {
  // Text type
  /** @deprecated Use {@linkcode TextType.Based.Characters} */
  Characters = TextType.Based.Characters,
  /** @deprecated Use {@linkcode TextType.Based.CharacterExcludingSpaces} */
  CharacterExcludingSpaces = TextType.Based.CharacterExcludingSpaces,
  /** @deprecated Use {@linkcode TextType.Based.Words} */
  Words = TextType.Based.Words,
  /** @deprecated Use {@linkcode TextType.Based.Lines} */
  Lines = TextType.Based.Lines,

  // Text caps
  /** @deprecated Use {@linkcode TextType.Caps.Regular} */
  Regular = TextType.Caps.Regular,
  /** @deprecated Use {@linkcode TextType.Caps.AllCaps} */
  AllCaps = TextType.Caps.AllCaps,
  /** @deprecated Use {@linkcode TextType.Caps.SmallCaps} */
  SmallCaps = TextType.Caps.SmallCaps,

  // Grouping
  /** @deprecated Use {@linkcode TextType.Grouping.Word} */
  Word = TextType.Grouping.Word,
  /** @deprecated Use {@linkcode TextType.Grouping.Line} */
  Line = TextType.Grouping.Line,
  /** @deprecated Use {@linkcode TextType.Grouping.All} */
  All = TextType.Grouping.All,

  // Justify
  /** @deprecated Use {@linkcode TextType.Justify.Left} */
  Left = TextType.Justify.Left,
  /** @deprecated Use {@linkcode TextType.Justify.Right} */
  Right = TextType.Justify.Right,
  /** @deprecated Use {@linkcode TextType.Justify.Center} */
  Center = TextType.Justify.Center,
  /** @deprecated Use {@linkcode TextType.Justify.WithLastLineLeft} */
  WithLastLineLeft = TextType.Justify.WithLastLineLeft,
  /** @deprecated Use {@linkcode TextType.Justify.WithLastLineRight} */
  WithLastLineRight = TextType.Justify.WithLastLineRight,
  /** @deprecated Use {@linkcode TextType.Justify.WithLastLineCenter} */
  WithLastLineCenter = TextType.Justify.WithLastLineCenter,
  /** @deprecated Use {@linkcode TextType.Justify.WithLastLineFull} */
  WithLastLineFull = TextType.Justify.WithLastLineFull,

  // Shape
  /** @deprecated Use {@linkcode TextType.Shape.Square} */
  Square = TextType.Shape.Square,
  /** @deprecated Use {@linkcode TextType.Shape.RampUp} */
  RampUp = TextType.Shape.RampUp,
  /** @deprecated Use {@linkcode TextType.Shape.RampDown} */
  RampDown = TextType.Shape.RampDown,
  /** @deprecated Use {@linkcode TextType.Shape.Triangle} */
  Triangle = TextType.Shape.Triangle,
  /** @deprecated Use {@linkcode TextType.Shape.Round} */
  Round = TextType.Shape.Round,
  /** @deprecated Use {@linkcode TextType.Shape.Smooth} */
  Smooth = TextType.Shape.Smooth,

  // Font path origin
  /** @deprecated Use {@linkcode TextType.FontPathOrigin.Local} */
  Local = TextType.FontPathOrigin.Local,
  /** @deprecated Use {@linkcode TextType.FontPathOrigin.CssUrl} */
  CssUrl = TextType.FontPathOrigin.CssUrl,
  /** @deprecated Use {@linkcode TextType.FontPathOrigin.ScriptUrl} */
  ScriptUrl = TextType.FontPathOrigin.ScriptUrl,
  /** @deprecated Use {@linkcode TextType.FontPathOrigin.FontUrl} */
  FontUrl = TextType.FontPathOrigin.FontUrl,

  // Vertical justify
  /** @deprecated Use {@linkcode TextType.VerticalJustify.Top} */
  VerticalJustifyTop = TextType.VerticalJustify.Top,
  /** @deprecated Use {@linkcode TextType.VerticalJustify.Center} */
  VerticalJustifyCenter = TextType.VerticalJustify.Center,
  /** @deprecated Use {@linkcode TextType.VerticalJustify.Bottom} */
  VerticalJustifyBottom = TextType.VerticalJustify.Bottom,

  // Range selector mode
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Add} */
  Add = TextType.RangeSelectorMode.Add,
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Subtract} */
  Subtract = TextType.RangeSelectorMode.Subtract,
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Intersect} */
  Intersect = TextType.RangeSelectorMode.Intersect,
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Min} */
  Min = TextType.RangeSelectorMode.Min,
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Max} */
  Max = TextType.RangeSelectorMode.Max,
  /** @deprecated Use {@linkcode TextType.RangeSelectorMode.Difference} */
  Difference = TextType.RangeSelectorMode.Difference,
}
declare namespace TextType {
  enum Based {
    Characters = 1,
    CharacterExcludingSpaces = 2,
    Words = 3,
    Lines = 4,
  }
  /** @deprecated Use the {@linkcode TextType.Based} enum */
  const enum BASED {
    CHARACTERS = Based.Characters,
    CHARACTER_EXCLUDING_SPACES = Based.CharacterExcludingSpaces,
    WORDS = Based.Words,
    LINES = Based.Lines,
  }

  /**
   * @default 0
   */
  enum Caps {
    Regular = 0,
    AllCaps = 1,
    SmallCaps = 2,
  }
  /** @deprecated Use the {@linkcode TextType.Caps} enum */
  const enum TEXT_CAPS {
    REGULAR = Caps.Regular,
    ALL_CAPS = Caps.AllCaps,
    SMALL_CAPS = Caps.SmallCaps,
  }

  enum Grouping {
    Characters = 1,
    Word = 2,
    Line = 3,
    All = 4,
  }
  /** @deprecated Use the {@linkcode TextType.Grouping} enum */
  const enum GROUPING {
    CHARACTERS = Grouping.Characters,
    WORD = Grouping.Word,
    LINE = Grouping.Line,
    ALL = Grouping.All,
  }

  /**
   * Text alignment / justification
   *
   * @default 0
   */
  enum Justify {
    Left = 0,
    Right = 1,
    Center = 2,
    WithLastLineLeft = 3,
    WithLastLineRight = 4,
    WithLastLineCenter = 5,
    WithLastLineFull = 6,
  }
  /** @deprecated Use the {@linkcode TextType.Justify} enum */
  const enum JUSTIFY {
    LEFT = Justify.Left,
    RIGHT = Justify.Right,
    CENTER = Justify.Center,
    WITH_LAST_LINE_LEFT = Justify.WithLastLineLeft,
    WITH_LAST_LINE_RIGHT = Justify.WithLastLineRight,
    WITH_LAST_LINE_CENTER = Justify.WithLastLineCenter,
    WITH_LAST_LINE_FULL = Justify.WithLastLineFull,
  }

  enum Shape {
    Square = 1,
    RampUp = 2,
    RampDown = 3,
    Triangle = 4,
    Round = 5,
    Smooth = 6,
  }
  /** @deprecated Use the {@linkcode TextType.Shape} enum */
  const enum SHAPE {
    SQUARE = Shape.Square,
    RAMP_UP = Shape.RampUp,
    RAMP_DOWN = Shape.RampDown,
    TRIANGLE = Shape.Triangle,
    ROUND = Shape.Round,
    SMOOTH = Shape.Smooth,
  }

  enum FontPathOrigin {
    Local = 0,
    CssUrl = 1,
    ScriptUrl = 2,
    FontUrl = 3,
  }
  /** @deprecated Use the {@linkcode TextType.FontPathOrigin} enum */
  enum FONT_PATH_ORIGIN {
    LOCAL = FontPathOrigin.Local,
    CSS_URL = FontPathOrigin.CssUrl,
    SCRIPT_URL = FontPathOrigin.ScriptUrl,
    FONT_URL = FontPathOrigin.FontUrl,
  }

  enum VerticalJustify {
    Top = 0,
    Center = 1,
    Bottom = 2,
  }
  /** @deprecated Use the {@linkcode TextType.VerticalJustify} enum */
  const enum VERTICAL_JUSTIFY {
    TOP = VerticalJustify.Top,
    CENTER = VerticalJustify.Center,
    BOTTOM = VerticalJustify.Bottom,
  }

  enum RangeSelectorMode {
    Add = 0,
    Subtract = 1,
    Intersect = 2,
    Min = 3,
    Max = 4,
    Difference = 5,
  }
  /** @deprecated Use the {@linkcode TextType.RangeSelectorMode} enum */
  const enum RANGE_SELECTOR_MODE {
    ADD = RangeSelectorMode.Add,
    SUBTRACT = RangeSelectorMode.Subtract,
    INTERSECT = RangeSelectorMode.Intersect,
    MIN = RangeSelectorMode.Min,
    MAX = RangeSelectorMode.Max,
    DIFFERENCE = RangeSelectorMode.Difference,
  }
}

/**
 * How to handle multiple shapes in trim path
 */
declare enum TrimMultipleShapes {
  Individually = 1,
  Simultaneously = 2,
}
declare namespace TrimMultipleShapes {
  type Value = TrimMultipleShapes;

  /** @deprecated Use the {@linkcode TrimMultipleShapes} enum */
  const enum VALUES {
    INDIVIDUALLY = TrimMultipleShapes.Individually,
    SIMULTANEOUSLY = TrimMultipleShapes.Simultaneously,
  }
}

declare enum LayerStyleType {
  Stroke = 0,
  DropShadow = 1,
  InnerShadow = 2,
  OuterGlow = 3,
  InnerGlow = 4,
  BevelEmboss = 5,
  Satin = 6,
  ColorOverlay = 7,
  GradientOverlay = 8,
}

declare namespace LayerStyleType {
  type Value = LayerStyleType;
}

declare namespace Helpers {
  /**
   * Index used in expressions
   */
  type PropertyIndex = {
    ix?: number;
  };

  /**
   * Name, as seen from editors and the like
   * @note mainly for labeling
   */
  type Name = {
    nm?: string;
  };

  /**
   * Match name, used in expressions. Mainly for scripting
   * and packaging. Unique identifier
   */
  type MatchName = {
    mn?: string;
  };

  type Expression = {
    x?: string;
  };

  /**
   * @default 0
   */
  type Width = number;

  /**
   * @default 0
   */
  type Height = number;

  /**
   * @default ""
   */
  type ID = string;

  type Hidden = boolean;

  type Index = number;

  type CssClass = string;

  type InPoint = number;

  type OutPoint = number;

  /**
   * Framerate in frames per second
   * @default 60
   */
  type Framerate = {
    fr?: number;
  };

  /**
   * @default 0
   */
  type Time = number;

  type VisualObject = Name & MatchName;

  /**
   * Represents boolean values as an integer. 0 is false, 1 is true.
   * @default 0
   */
  type IntegerBoolean = 0 | 1;

  /**
   * Color as a [r, g, b] array with values in [0, 1]
   * @minimum 0
   * @maximum 1
   */
  type ColorRgba = [number, number, number] | [number, number, number, number];

  /**
   * Whether the animation has 3D layers. Lottie doesn't actually support 3D stuff so this should always be 0
   */
  type Threedimensional = {
    ddd?: IntegerBoolean;
  };

  /**
   * Number of components in the value arrays.\nIf present values will be truncated or expanded to match this length when accessed from expressions.
   * @type integer
   */
  type Length = {
    l?: number;
  };

  /**
   * Rotation in degrees, clockwise
   */
  type RotationClockwise = {
    r: AnimatedProperty.Value;
  };

  type RotationXYZ = {
    /**
     * X Rotation - Split rotation component
     */
    rx?: AnimatedProperty.Value;
    /**
     * Y Rotation - Split rotation component
     */
    ry?: AnimatedProperty.Value;
    /**
     * ZRotation - Split rotation component, equivalent to `r` when not split
     */
    rz?: AnimatedProperty.Value;
    /**
     * Orientation
     */
    or?: AnimatedProperty.MultiDimensional;
  };

  type TransformRotation = RotationClockwise | RotationXYZ;

  /**
   * Layer transform
   */
  type Transform = TransformRotation &
    VisualObject & {
      /**
       * Anchor point
       *
       * a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)
       */
      a?: AnimatedProperty.Position;
      /**
       * Scale factor, `[100, 100]` for no scaling
       */
      s?: AnimatedProperty.MultiDimensional;
      /**
       * Opacity
       */
      o?: AnimatedProperty.Value;
      /**
       * Skew
       *
       * Skew amount as an angle in degrees
       */
      sk?: AnimatedProperty.Value;
      /**
       * Skew Axis
       *
       * Direction along which skew is applied, in degrees (`0` skews along the X axis, `90` along the Y axis)
       */
      sa?: AnimatedProperty.Value;
      /**
       * Position - Translation or Translation with split components
       */
      p?: AnimatedProperty.Position | AnimatedProperty.SplitVector;
    };

  /**
   * Bezier shape used to mask/clip a layer
   */
  type Mask = Helpers.VisualObject & {
    /**
     * Inverted
     * @default false
     */
    inv?: boolean;
    /**
     * Mask Vertices
     */
    pt?: AnimatedProperty.Shape;
    /**
     * Opacity
     */
    o?: AnimatedProperty.Value;
    /**
     * Mode
     * @default 'i' (ModeIntersect)
     */
    mode?: MaskMode.Value;
    /**
     * Dilate
     */
    x?: AnimatedProperty.Value;
  };

  /**
   * Single bezier curve
   */
  interface Bezier {
    /**
     * Closed
     * @default False
     */
    c?: boolean;
    /**
     * In Tangents
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the `in` tangents relative to the corresponding `v`.
     *
     * @default []
     */
    i: number[][];
    /**
     * Out Tangents
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the `out` tangents relative to the corresponding `v`.
     */
    o: number[][];
    /**
     * Vertices
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the bezier path
     */
    v: number[][];
  }

  /**
   * One of the ID in the file's slots
   */
  type SlotID = string;
}

declare type AnimatedProperty = AnimatedProperty.Value;
declare namespace AnimatedProperty {
  /**
   * Bezier handle for keyframe interpolation
   */
  interface KeyframeBezierHandle {
    /**
     * Time component:\n0 means start time of the keyframe,\n1 means time of the next keyframe.
     *
     * @if type array
     * @then minItems: 1
     * @default 0
     */
    x: number[] | number;
    /**
     * Value interpolation component:\n0 means start value of the keyframe,\n1 means value at the next keyframe.
     *
     * @if type array
     * @then minItems: 1
     * @default 0
     */
    y: number[] | number;
  }

  /**
   * A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe
   *
   * 'i' and 'o' are not included in the last element of the keyframe array usually when the
   * Bezier curve is not closed, or when the last vertex is defined by the last element is the
   * same as the first vertex.
   *
   * @if "h": { "const": 0 | undefined }
   * @then 'i' and 'o'
   */
  interface KeyframeBase {
    /**
     * Time
     * @default 0
     */
    t: Helpers.Time;
    /**
     * Hold
     * @default 0
     */
    h?: Helpers.IntegerBoolean;
    /**
     * In Tangent
     *
     * Easing tangent going into the next keyframe
     *
     * @if "h": { "const": 0 | undefined }
     * @then 'i' is present
     */
    i?: KeyframeBezierHandle;
    /**
     * Out Tangent
     *
     * Easing tangent leaving the current keyframe
     *
     * @if "h": { "const": 0 | undefined }
     * @then 'o' is present
     */
    o?: KeyframeBezierHandle;
    /**
     * Start
     */
    s: number[] | Helpers.Bezier[];
  }

  /**
   * A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.
   */
  interface Keyframe extends KeyframeBase {
    /**
     * Value
     *
     * Value at this keyframe. Note the if the property is a scalar, keyframe values are still represented as arrays
     */
    s: number[];
    /**
     * End Value
     *
     * Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value
     *
     * @deprecated true
     */
    e?: number[];
  }

  /**
   * Keyframe holding Bezier objects
   */
  interface ShapeKeyframe extends KeyframeBase {
    /**
     * Keyframe end value
     *
     * depends on "v"
     */
    e?: Helpers.Bezier;
    /**
     * Start
     */
    s: Helpers.Bezier[];
  }

  interface Main
    extends Helpers.PropertyIndex,
      Helpers.VisualObject,
      Helpers.Expression {
    /**
     * Animated - Whether the property is animated
     * @default 0
     */
    a?: Helpers.IntegerBoolean;
    /**
     * 'k' is the list of keyframes that define the change and the rate of change of
     * an animated property between any given two frames. therefore, 'k' is require for
     * all animated properties.
     */
    k:
      | Keyframe[]
      | Helpers.ColorRgba
      | ShapeKeyframe[]
      | Helpers.Bezier
      | number[]
      | number;
    /**
     * Slot ID
     *
     * One of the ID in the file's slots
     */
    sid?: Helpers.SlotID;
  }

  /**
   * An animatable property that holds an array of numbers
   */
  interface MultiDimensional extends Main, Helpers.Length {
    /**
     * @if "a": { "const": 1  }
     * @then Animated value - Keyframe[];
     * @else Static Value
     */
    k: Keyframe[] | number[];
  }

  /**
   * An animatable property that holds a Color
   */
  interface Color extends Main {
    /**
     * @if "a": { "const": 1  }
     * @then Animated value - Keyframe[];
     * @else Static Value - Color
     */
    k: Keyframe[] | Helpers.ColorRgba;
  }

  /**
   * Represents colors and offsets in a gradient
   *
   * Colors are represented as a flat list interleaving offsets and color components in weird ways
   * There are two possible layouts:
   *
   * Without alpha, the colors are a sequence of offset, r, g, b
   *
   * With alpha, same as above but at the end of the list there is a sequence of offset, alpha.
   *
   */
  interface GradientColors {
    /**
     * Colors
     */
    k: MultiDimensional;
    /**
     * Count
     * Number of colors in `k`
     * @default 0
     */
    p: number;
  }

  interface PositionKeyframe extends Keyframe {
    /**
     * Value In Tangent
     * Tangent for values (eg: moving position around a curved path
     */
    ti?: number[];
    /**
     * Value Out Tangent
     * Tangent for values (eg: moving position around a curved path
     */
    to?: number[];
  }

  /**
   * An animatable property to represent a position in space
   */
  interface Position extends Main, Helpers.Length {
    /**
     * @if "a": { "const": 1  }
     * @then Animated Value - PositionKeyframe[]
     * @else Static Value - number[]
     */
    k: PositionKeyframe[] | number[];
  }

  /**
   * An animatable property that holds a Bezier
   */
  interface Shape extends Main {
    /**
     * @if "a": { "const": 1  }
     * @then Animated Value - ShapeKeyframe[]
     * @else Static Value - Bezier
     */
    k: ShapeKeyframe[] | Helpers.Bezier;
  }

  /**
   * An animatable property that holds a float
   */
  interface Value extends Main {
    /**
     * @if "a": { "const": 1  }
     * @then Animated Value - Keyframe[]
     * @else Static Value - number
     */
    k: Keyframe[] | number;
  }

  /**
   *  An animatable property that is split into individually anaimated components
   */
  interface SplitVector {
    /**
     * Split
     */
    s: true;
    x: Value;
    y: Value;
    z?: Value;
  }
}

declare type Shape = Shape.Value;
declare namespace Shape {
  type Opacity = AnimatedProperty;

  /**
   * Base class for all elements of ShapeLayer and Group
   */
  interface Element extends Helpers.VisualObject, Helpers.PropertyIndex {
    /**
     * Whether the shape is hidden
     */
    hd?: Helpers.Hidden;
    ty: ShapeType.Value;
    bm?: BlendMode.Value;
    /**
     * Property Index
     *
     * Index used in expressions
     */
    cix?: Helpers.Index;
    /**
     * CSS Class
     *
     * CSS class used by the SVG renderer.
     */
    cl?: Helpers.CssClass;
    /**
     * Shape XML ID
     *
     * ID attribute used by the SVG renderer.
     */
    ln?: Helpers.ID;
  }

  /**
   * Drawable shape
   */
  interface Main extends Element {
    /**
     * Direction
     *
     * Direction the shape is drawn as, mostly relevant when using trim path
     */
    d?: ShapeDirection.Value;
  }

  interface Ellipse extends Main {
    ty: ShapeType.Ellipse;
    /**
     * Position
     */
    p: AnimatedProperty.Position;
    /**
     * Size
     */
    s: AnimatedProperty.MultiDimensional;
  }

  /**
   * Solid fill color
   */
  interface Fill extends Element {
    ty: ShapeType.Fill;
    o: Opacity;
    /**
     * Color
     */
    c: AnimatedProperty.Color;
    /**
     * Fill Rule
     */
    r?: FillRule.Value;
  }

  interface Gradient extends Element {
    /**
     * StartPoint
     */
    s: AnimatedProperty.MultiDimensional;
    /**
     * EndPoint
     */
    e: AnimatedProperty.MultiDimensional;
    t?: GradientType.Value;
    /**
     * Highlight Length
     */
    h?: AnimatedProperty.Value;
    /**
     * Highlight Angle
     */
    a?: AnimatedProperty.Value;
    /**
     * Colors
     */
    g: AnimatedProperty.GradientColors;
  }

  interface GradientFill extends Gradient {
    ty: ShapeType.GradientFill;
    o: Opacity;
    r?: FillRule.Value;
  }

  /**
   * An item used to described the dashe pattern in a stroked path
   */
  interface StrokeDash extends Helpers.VisualObject {
    /**
     * @default 'd'
     */
    n?: StrokeDashType.Value;
    /**
     * Length
     */
    v?: AnimatedProperty.Value;
  }

  interface BaseStroke {
    /**
     * @default 2
     */
    lc?: LineCap.Value;
    /**
     * @default 2
     */
    lj?: LineJoin.Value;
    /**
     * Miter Limit
     * @default 0
     */
    ml?: number;
    /**
     * Animatable alternative to ml
     */
    ml2?: AnimatedProperty.Value;
    o: Opacity;
    /**
     * Width
     */
    w: AnimatedProperty.Value;
    /**
     * Dashes
     */
    d?: StrokeDash[];
  }

  interface GradientStroke extends Gradient, BaseStroke {
    ty: ShapeType.GradientStroke;
  }

  /**
   * Shape Element that can contain other shapes
   */
  interface Group extends Element {
    ty: ShapeType.Group;
    /**
     * NumberOfProperties
     */
    np?: number;
    it?: Value[];
    /**
     * Property Index
     *
     * Index used in expressions
     * @type integer
     */
    cix?: number;
  }

  /**
   * Animatable Bezier curve
   */
  interface Path extends Main {
    ty: ShapeType.Path;
    /**
     * Shape
     */
    ks: AnimatedProperty.Shape;
    ind?: Helpers.Index;
  }

  interface IPolyStar extends Main {
    ty: ShapeType.PolygonStar;
    /**
     * Position
     */
    p: AnimatedProperty.Position;
    /**
     * Outer Radius
     */
    or: AnimatedProperty.Value;
    /**
     * Outer Roundness
     *
     * Outer Roundness as a percentage
     */
    os: AnimatedProperty.Value;
    /**
     * Rotation, clockwise in degrees
     */
    r: AnimatedProperty.Value;
    /**
     * Points
     */
    pt: AnimatedProperty.Value;
    /**
     * @default 1
     */
    sy?: PolyStarType.Value;
  }

  interface Polygon extends IPolyStar {
    sy: PolyStarType.Polygon;
  }

  interface Star extends IPolyStar {
    sy: PolyStarType.Star;
    /**
     * Inner Radius
     */
    ir: AnimatedProperty.Value;
    /**
     * Inner Roundness
     *
     * Inner Roundness as a percentage
     */
    is: AnimatedProperty.Value;
  }

  /**
   * Star or regular polygon
   * @if { "sy": 1 }
   * @then Star
   * @else Polygon
   */
  type PolyStar = Star | Polygon;

  /**
   * Interpolates the shape with its center point and bezier tangents with the opposite direction
   */
  interface PuckerBloat extends Element {
    ty: ShapeType.PuckerBloat;
    /**
     * Amount
     *
     * Amount as a percentage
     */
    a?: AnimatedProperty.Value;
  }

  /**
   * A simple rectangle shape
   */
  interface Rectangle extends Main {
    ty: ShapeType.Rectangle;
    /**
     * Position
     *
     * Center of the rectangle
     */
    p: AnimatedProperty.Position;
    /**
     * Size
     */
    s: AnimatedProperty.MultiDimensional;
    /**
     * Rounded
     */
    r: AnimatedProperty.Value;
  }

  interface Modifier extends Element {}

  /**
   * Transform used by a repeater, the transform is applied to each subsequent repeated object.
   */
  type RepeaterTransform = Helpers.Transform & {
    /**
     * Start Opacity
     *
     * Opacity of the first repeated object.
     */
    so?: Opacity;
    /**
     * End Opacity
     *
     * Opacity of the last repeated object.
     */
    eo?: Opacity;
  };

  /**
   * Duplicates previous shapes in a group
   */
  interface Repeater extends Modifier {
    ty: ShapeType.Repeater;
    /**
     * Copies
     */
    c: AnimatedProperty.Value;
    /**
     * Offset
     */
    o?: AnimatedProperty.Value;
    /**
     * @default 1
     */
    m?: Composite.Value;
    /**
     * Transform
     */
    tr: RepeaterTransform;
  }

  /**
   * Rounds corners of other shapes
   */
  interface RoundedCorners extends Modifier {
    ty: ShapeType.RoundedCorners;
    /**
     * Radius
     */
    r: AnimatedProperty.Value;
  }

  /**
   * Solid stroke
   */
  interface Stroke extends Element, BaseStroke {
    ty: ShapeType.Stroke;
    /**
     * Color
     */
    c: AnimatedProperty.MultiDimensional;
  }

  /**
   * Group transform
   */
  type Transform = Element &
    Helpers.Transform & {
      ty: ShapeType.Transform;
    };

  /**
   * Trims shapes into a segment
   */
  interface Trim extends Modifier {
    ty: ShapeType.Trim;
    /**
     * Start
     */
    s: AnimatedProperty.Value;
    /**
     * End
     */
    e: AnimatedProperty.Value;
    /**
     * Offset
     */
    o: AnimatedProperty.Value;
    /**
     * Multiple
     */
    m?: TrimMultipleShapes.Value;
  }

  interface Twist extends Element {
    ty: ShapeType.Twist;
    /**
     * Angle
     */
    a?: AnimatedProperty.Value;
    /**
     * Center
     */
    c?: AnimatedProperty.MultiDimensional;
  }

  interface Merge extends Element {
    ty: ShapeType.Merge;
    /**
     * Merge Mode
     * @default 1
     */
    mm?: number;
  }

  /**
   * Interpolates the shape with its center point and bezier tangents with the opposite direction
   */
  interface OffsetPath extends Element {
    ty: ShapeType.OffsetPath;
    /**
     * Amount
     */
    a?: AnimatedProperty.Value;
    /**
     * @default 2
     */
    lj?: LineJoin.Value;
    /**
     * Miter Limit
     */
    ml?: AnimatedProperty.Value;
  }

  /**
   * Changes the edges of affected shapes into a series of peaks and valleys of uniform size
   */
  interface ZigZags extends Element {
    ty: ShapeType.ZigZag;
    /**
     * Roundness
     *
     * Radius to maked it a smoother curve
     */
    r?: AnimatedProperty.Value;
    /**
     * Size
     *
     * Distance between peaks and troughs
     */
    s?: AnimatedProperty.Value;
    /**
     * Points
     *
     * Number of ridges
     */
    pt?: AnimatedProperty.Value;
  }

  /**
   * List of valid shapes (prev. Shape List)
   */
  type Value =
    | Ellipse
    | Fill
    | GradientFill
    | GradientStroke
    | Group
    | Path
    | PolyStar
    | PuckerBloat
    | Rectangle
    | Repeater
    | RoundedCorners
    | Stroke
    | Transform
    | Trim
    | Twist
    | Merge
    | OffsetPath
    | ZigZags;
}

declare namespace Text {
  /**
   * @default ""
   */
  type FontFamily = string;
  type FontSize = number;
  type FontStyle = string;

  /**
   * Defines a character as shapes
   */
  interface CharacterShapes {
    /**
     * Shape forming the character
     */
    shapes: Shape.Value[];
  }

  /**
   * Defines a character as a precomp layer
   */
  interface CharacterPrecomp {
    /**
     * Reference Id
     *
     * ID of the precomp as specified in the assets
     */
    refId: Helpers.ID;
    /**
     * Transform
     *
     * Layer transform
     */
    ks?: Helpers.Transform;
    /**
     * In Point
     *
     * Frame when the layer becomes visible
     *
     * @default 0
     */
    ip?: Helpers.InPoint;
    /**
     * Out Point
     *
     * Frame when the layer becomes invisible
     * @default 99999
     */
    op?: Helpers.OutPoint;
    /**
     * Time Stretch
     * @default 1
     */
    sr?: Helpers.Time;
    /**
     * Start Time
     *
     * @default 0
     */
    st?: Helpers.Time;
  }

  /**
   * Defines character shapes
   */
  interface CharacterData {
    data: CharacterShapes | CharacterPrecomp;
    /**
     * Character
     * @default ""
     */
    ch: string;
    /**
     * @default ""
     */
    fFamily: FontFamily;
    /**
     * @default 0
     */
    size: FontSize;
    /**
     * @default ""
     */
    style: FontStyle;
    w: Helpers.Width;
  }

  /*
   * Describes how a font with given settings should be loaded
   */
  interface Font {
    /**
     * Ascent
     *
     * Text will be moved down based on this value
     */
    ascent?: number;
    /**
     * Font Family
     *
     * @default "sans"
     */
    fFamily: FontFamily;
    /**
     * Font Name
     *
     * Name used by text documents to reference this font, usually it's `fFamily` followed by `fStyle`
     * @default "sans-regular"
     */
    fName: string;
    /**
     * Font Style
     *
     * @default "Regular"
     * @example ["Regular", "Bold", "Bold Italic"]
     */
    fStyle: FontStyle;
    /**
     * Font Path
     */
    fPath?: string;
    /**
     * Font Weight
     */
    fWeight?: string;
    /**
     * Origin
     */
    origin: TextType.FontPathOrigin;
    /**
     * Font CSS Class
     *
     * CSS class applied to text objects using this font
     */
    fClass?: Helpers.CssClass;
  }

  interface FontList {
    list?: Font[];
  }

  /**
   * Uses the path described by a layer mask to put the text on said path.
   */
  interface FollowPath {
    /**
     * Mask
     *
     * Index of the mask to use
     *
     * @type integer
     */
    m?: number;
    /**
     * First Margin
     */
    f?: AnimatedProperty.Value;
    /**
     * Last Margin
     */
    l?: AnimatedProperty.Value;
    /**
     * Reverse Path
     */
    r?: AnimatedProperty.Value;
    /**
     * Force Alignment
     */
    a?: AnimatedProperty.Value;
    /**
     * Perpendicular To Path
     */
    p?: AnimatedProperty.Value;
  }

  /**
   * Text Animator Data Property
   */
  type Style = Helpers.Transform & {
    /**
     * Stroke Width
     */
    sw?: AnimatedProperty.Value;
    /**
     * Stroke Color
     */
    sc?: AnimatedProperty.Color;
    /**
     * Stroke Hue
     */
    sh?: AnimatedProperty.Value;
    /**
     * Stroke Saturation
     */
    ss?: AnimatedProperty.Value;
    /**
     * Stroke Brightness
     */
    sb?: AnimatedProperty.Value;
    /**
     * Stroke Opacity
     */
    so?: AnimatedProperty.Value;
    /**
     * Fill Color
     */
    fc?: AnimatedProperty.Color;
    /**
     * Fill Hue
     */
    fh?: AnimatedProperty.Value;
    /**
     * Fill Saturation
     */
    fs?: AnimatedProperty.Value;
    /**
     * Fill Opacity
     */
    fo?: AnimatedProperty.Value;
    /**
     * Fill Brightness
     */
    fb?: AnimatedProperty.Value;
    /**
     * Tracking
     */
    t?: AnimatedProperty.Value;
    /**
     * Blur
     */
    bl?: AnimatedProperty.Value;
    /**
     * Line Spacing
     */
    ls?: AnimatedProperty.Value;
  };

  /**
   * Animated Text Document
   * Animated property representing the text contents
   */
  interface AnimatedDocument extends Helpers.Expression {
    k: DocumentKeyframe[];
    /**
     * Slot ID
     *
     * One of the ID in the file's slots
     */
    sid?: Helpers.SlotID;
  }

  /**
   * Text Range Selector
   */
  interface Selector {
    /**
     * Expressible
     */
    t: Helpers.IntegerBoolean;
    /**
     * Max Ease
     */
    xe?: AnimatedProperty.Value;
    /**
     * Min Ease
     */
    ne?: AnimatedProperty.Value;
    /**
     * Max Amount
     */
    a: AnimatedProperty.Value;
    /**
     * Based On
     */
    b: TextType.Based;
    /**
     * Randomize
     */
    rn?: Helpers.IntegerBoolean;
    /**
     * Shape
     */
    sh: TextType.Shape;
    /**
     * Offset
     */
    o?: AnimatedProperty.Value;
    /**
     * Range Units
     *
     * @type integer
     */
    r?: number;
    /**
     * Selector Smoothness
     */
    sm?: AnimatedProperty.Value;
    /**
     * Start
     */
    s?: AnimatedProperty.Value;
    /**
     * End
     */
    e?: AnimatedProperty.Value;
  }

  /**
   * Range of text with custom animations and style
   */
  interface Range extends Helpers.Name {
    /**
     * Transform
     */
    a?: Style;
    s?: Selector;
  }

  /**
   * Text Alignment Options
   */
  interface AlignmentOptions {
    /**
     * Alignment
     *
     * Group alignment
     */
    a?: AnimatedProperty.MultiDimensional;
    /**
     * Anchor point grouping
     */
    g?: TextType.Grouping;
  }

  /**
   * Text Document
   */
  interface Document {
    /**
     * Font Family
     * @default ""
     */
    f: FontFamily;
    /**
     * Fill Color
     * @default [0,0,0]
     */
    fc: Helpers.ColorRgba;
    /**
     * Stroke Color
     */
    sc?: Helpers.ColorRgba;
    /**
     * Stroke Width
     * @default 0
     */
    sw?: number;
    /**
     * Stroke Over Fill
     * Render stroke above the fill
     */
    of?: boolean;
    /**
     * Font Size
     *
     * @default 10
     */
    s: FontSize;
    /**
     * Line Height
     *
     * Distance between lines on multiline or wrapped text
     */
    lh?: number;
    /**
     * Wrap Size
     *
     * Size of the box containing the text
     */
    sz?: [number, number];
    /**
     * Wrap Position
     *
     * Position of the box containing the text
     */
    ps?: [number, number];
    /**
     * Text
     *
     * Text, note that newlines are encoded with \\r
     * @default ''
     */
    t: string;
    /**
     * Justify
     *
     * @default 0
     */
    j?: TextType.Justify;
    /**
     * Text Caps
     */
    ca?: TextType.Caps;
    /**
     * Text Tracking
     */
    tr?: number;
    /**
     * Baseline Shift
     */
    ls?: number;
    /**
     * Vertical justification. (Skottie)
     */
    vj?: TextType.VerticalJustify;
  }

  /**
   * Text Document Keyframe
   *
   * A keyframe containing a text document
   */
  interface DocumentKeyframe {
    /**
     * Start
     */
    s: Document;
    /**
     * Start time of keyframe segment.
     *
     * @default 0
     */
    t: Helpers.Time;
  }

  /**
   * Text Data
   *
   * Animated property representing the text contents
   */
  interface Data {
    a: Range[];
    d: AnimatedDocument;
    m: AlignmentOptions;
    p: FollowPath;
  }
}

declare type EffectValue = EffectValue.Value;
declare namespace EffectValue {
  interface Main extends Helpers.VisualObject, Helpers.PropertyIndex {
    ty?: EffectValueType.Value;
    v?:
      | AnimatedProperty.Value
      | AnimatedProperty.Color
      | AnimatedProperty.MultiDimensional
      | number;
  }

  interface NoValue extends Main {}

  interface Angle extends Main {
    ty: EffectValueType.Angle;
    v?: AnimatedProperty.Value;
  }

  interface Checkbox extends Main {
    ty: EffectValueType.Checkbox;
    v?: AnimatedProperty.Value;
  }

  interface Color extends Main {
    ty: EffectValueType.Color;
    v?: AnimatedProperty.Color;
  }

  interface DropDown extends Main {
    ty: EffectValueType.Dropdown;
    v?: AnimatedProperty.Value;
  }

  interface IgnoredValue extends Main {
    ty: EffectValueType.Ignored;
    v?: number;
  }

  interface Layer extends Main {
    ty: EffectValueType.Layer;
    v?: AnimatedProperty.Value;
  }

  interface Point extends Main {
    ty: EffectValueType.Point;
    v?: AnimatedProperty.MultiDimensional;
  }

  interface Slider extends Main {
    ty: EffectValueType.Slider;
    v?: AnimatedProperty.Value;
  }

  type Value =
    | NoValue
    | Angle
    | Checkbox
    | Color
    | DropDown
    | IgnoredValue
    | Layer
    | Point
    | Slider;
}

declare type Effect = Effect.Value;
declare namespace Effect {
  interface Main extends Helpers.VisualObject, Helpers.PropertyIndex {
    /** Effect Parameters */
    ef: EffectValue.Value[];
    ty: EffectType.Value;
    /** Enabled */
    en?: Helpers.IntegerBoolean;
    /**
     * NumberOfProperties
     */
    np?: number;
  }

  /**
   * Adds a shadow to the layer
   */
  interface DisplacementMap extends Main {
    ty: EffectType.DisplacementMap;
    ef: [
      /** Displacement Map Layer */
      EffectValue.Layer,
      /** Use For Horizontal Displacement */
      EffectValue.DropDown,
      /** Max Horizontal Displacement */
      EffectValue.Slider,
      /** Use For Vertical Displacement */
      EffectValue.DropDown,
      /** Max Vertical Displacement */
      EffectValue.Slider,
      /** Displacement Map Behavior */
      EffectValue.DropDown,
      /** Edge Behavior */
      EffectValue.DropDown,
      /** Expand Output */
      EffectValue.DropDown
    ];
  }

  interface DropShadow extends Main {
    ty: EffectType.DropShadow;
    ef: [
      /** Color */
      EffectValue.Color,
      /** Opacity between 0 and 255 */
      EffectValue.Slider,
      /** Angle */
      EffectValue.Angle,
      /** Distance */
      EffectValue.Slider,
      /** Blur */
      EffectValue.Slider
    ];
  }

  /**
   * Replaces the whole layer with the given color
   *
   * Opacity is in [0, 1]
   */
  interface Fill extends Main {
    ty: EffectType.Fill;
    ef: [
      /** 00 */
      EffectValue.Point,
      /** 01 */
      EffectValue.DropDown,
      /** Color */
      EffectValue.Color,
      /** Color */
      EffectValue.Color,
      /** 03 */
      EffectValue.DropDown,
      /** 04 */
      EffectValue.Slider,
      /** 05 */
      EffectValue.Slider,
      /** Opacity in [0, 1] */
      EffectValue.Slider
    ];
  }

  /**
   * Gaussian blur
   */
  interface GaussianBlur extends Main {
    ty: EffectType.GaussianBlur;
    ef: [
      /** Sigma */
      EffectValue.Slider,
      /** Dimensions */
      EffectValue.Slider,
      /** Wrap */
      EffectValue.Checkbox
    ];
  }

  interface Matte3 extends Main {
    ty: EffectType.Matte3;
    ef: [
      /** Index */
      EffectValue.Slider
    ];
  }

  interface MeshWarp extends Main {
    ty: EffectType.MeshWarp;
    ef: [
      /** Rows */
      EffectValue.Slider,
      /** Columns */
      EffectValue.Slider,
      /** Quality */
      EffectValue.Slider,
      /** 03 */
      EffectValue.NoValue
    ];
  }

  interface PaintOverTransparent extends Main {
    ty: EffectType.PaintOverTransparent;
    ef: [
      /** 00 */
      EffectValue.Slider
    ];
  }

  interface ProLevels extends Main {
    ty: EffectType.ProLevels;
    ef: [
      /** 00 */
      EffectValue.DropDown,
      /** 01 */
      EffectValue.NoValue,
      /** 02 */
      EffectValue.NoValue,
      /** comp_inblack */
      EffectValue.Slider,
      /** comp_inwhite */
      EffectValue.Slider,
      /** comp_gamma */
      EffectValue.Slider,
      /** comp_outblack */
      EffectValue.NoValue,
      /** comp_outwhite */
      EffectValue.NoValue,
      /** 08 */
      EffectValue.NoValue,
      /** 09 */
      EffectValue.Slider,
      /** r_inblack */
      EffectValue.Slider,
      /** r_inwhite */
      EffectValue.Slider,
      /** r_gamma */
      EffectValue.Slider,
      /** r_outblack */
      EffectValue.Slider,
      /** r_outwhite */
      EffectValue.Slider,
      /** 15 */
      EffectValue.Slider,
      /** 16 */
      EffectValue.Slider,
      /** g_inblack */
      EffectValue.Slider,
      /** g_inwhite */
      EffectValue.Slider,
      /** g_gamma */
      EffectValue.Slider,
      /** g_outblack */
      EffectValue.Slider,
      /** g_outwhite */
      EffectValue.Slider,
      /** 22 */
      EffectValue.Slider,
      /** 23 */
      EffectValue.Slider,
      /** b_inblack */
      EffectValue.Slider,
      /** b_inwhite */
      EffectValue.Slider,
      /** b_gamma */
      EffectValue.Slider,
      /** b_outblack */
      EffectValue.Slider,
      /** b_outwhite */
      EffectValue.Slider,
      /** 29 */
      EffectValue.Slider,
      /** a_inblack */
      EffectValue.Slider,
      /** a_inwhite */
      EffectValue.Slider,
      /** g_gamma */
      EffectValue.Slider,
      /** a_outblack */
      EffectValue.Slider,
      /** a_outwhite */
      EffectValue.Slider
    ];
  }

  interface Puppet extends Main {
    ty: EffectType.Puppet;
    ef: [
      /** Puppet Engine */
      EffectValue.DropDown,
      /** Mesh Rotation Refinement */
      EffectValue.Slider,
      /** On Transparent */
      EffectValue.DropDown,
      /** 03 */
      EffectValue.NoValue
    ];
  }

  interface RadialWipe extends Main {
    ty: EffectType.RadialWipe;
    ef: [
      /** Completion. Between 0 and 100 */
      EffectValue.Slider,
      /** Start Angle */
      EffectValue.Angle,
      /** Wipe Center */
      EffectValue.Point,
      /** Wipe */
      EffectValue.Slider,
      /** Feather */
      EffectValue.Slider
    ];
  }

  interface Spherize extends Main {
    ty: EffectType.Spherize;
    ef: [
      /** Radius */
      EffectValue.Slider,
      /** Center */
      EffectValue.Point
    ];
  }

  interface Stroke extends Main {
    ty: EffectType.Stroke;
    ef: [
      /** 00 */
      EffectValue.Color,
      /** 01 */
      EffectValue.Checkbox,
      /** 02 */
      EffectValue.Checkbox,
      /** Color */
      EffectValue.Color,
      /** 04 */
      EffectValue.Slider,
      /** 05 */
      EffectValue.Slider,
      /** 06 */
      EffectValue.Slider,
      /** 07 */
      EffectValue.Slider,
      /** 08 */
      EffectValue.Slider,
      /** 09 */
      EffectValue.DropDown,
      /** type */
      EffectValue.DropDown
    ];
  }

  /**
   * Colorizes the layer
   *
   * Opacity in [0, 100]
   */
  interface Tint extends Main {
    ty: EffectType.Tint;
    ef: [
      /**
       * Black Color.
       *
       * Tint of the darker parts of the layer.
       */
      EffectValue.Color,
      /**
       * White Color
       *
       * Tint of the lighter parts of the layer
       */
      EffectValue.Color,
      /**
       * Intensity
       *
       * Intensity of the effect, 0 means the layer is unchanged. 100 means full effect.
       */
      EffectValue.Slider
    ];
  }

  /**
   * Maps layers colors based on bright/mid/dark colors
   */
  interface Tritone extends Main {
    ty: EffectType.Tritone;
    ef: [
      /** Bright */
      EffectValue.Color,
      /** Mid */
      EffectValue.Color,
      /** Dark */
      EffectValue.Color
    ];
  }

  interface Wavy extends Main {
    ty: EffectType.Wavy;
    ef: [
      /** Radius */
      EffectValue.Slider,
      /** Center */
      EffectValue.Point,
      /** Conversion Type */
      EffectValue.DropDown,
      /** Speed */
      EffectValue.DropDown,
      /** Width */
      EffectValue.Slider,
      /** Height */
      EffectValue.Slider,
      /** Phase */
      EffectValue.Slider
    ];
  }

  /**
   * Some lottie files use `ty` = 5 for many different effects
   */
  interface Custom extends Main {
    ty: EffectType.Custom;
  }

  /**
   * Layer Effect
   */
  type Value =
    | Custom
    | DropShadow
    | Fill
    | GaussianBlur
    | Matte3
    | ProLevels
    | Stroke
    | Tint
    | Tritone
    | RadialWipe
    | Wavy
    | Puppet
    | Spherize
    | PaintOverTransparent
    | MeshWarp
    | DisplacementMap;
}

declare type Style = Style.Value;
declare namespace Style {
  type OpacityValue = AnimatedProperty.Value;

  type ColorValue = AnimatedProperty.Color;

  type AngleValue = AnimatedProperty.Value;

  interface ChokeSpread {
    ch?: AnimatedProperty.Value;
  }

  interface BlendMode {
    bm?: AnimatedProperty.Value;
  }

  interface Opacity {
    o?: OpacityValue;
  }

  /**
   * Size or Blur Size
   */
  interface Size {
    s?: AnimatedProperty.Value;
  }

  interface Noise {
    no?: AnimatedProperty.Value;
  }

  interface Distance {
    d?: AnimatedProperty.Value;
  }

  interface Color {
    c?: ColorValue;
  }

  /**
   * Local light angle
   */
  interface Angle {
    a?: AngleValue;
  }
  /**
   * Layer Style
   *
   * Style applied to a layer
   */
  interface Layer extends Helpers.VisualObject {
    /**
     * Type
     *
     * Style Type
     * @type integer
     */
    ty: LayerStyleType.Value;
  }

  interface Stroke extends Layer, Size, Color {
    ty: LayerStyleType.Stroke;
  }

  interface DropShadow
    extends Layer,
      Color,
      Opacity,
      Angle,
      Size,
      Distance,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.DropShadow;
    /**
     * Layer Conceal
     *
     * Layer knowck out drop shadow
     */
    lc?: AnimatedProperty.Value;
  }

  interface InnerShadow
    extends Layer,
      Color,
      Opacity,
      Angle,
      Size,
      Distance,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.InnerShadow;
  }

  interface OuterGlow
    extends Layer,
      Color,
      Opacity,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.OuterGlow;
    /**
     * Range
     */
    r?: AnimatedProperty.Value;
    /**
     * Jitter
     */
    j?: AnimatedProperty.Value;
  }

  interface InnerGlow extends Omit<OuterGlow, "ty"> {
    ty: LayerStyleType.InnerGlow;
    /**
     * Source
     */
    sr?: AnimatedProperty.Value;
  }

  interface BevelEmboss extends Layer, Size, Angle {
    ty: LayerStyleType.BevelEmboss;
    /**
     * Bevel Style
     */
    bs?: AnimatedProperty.Value;
    /**
     * Technique
     */
    bt?: AnimatedProperty.Value;
    /**
     * Strength
     */
    sr?: AnimatedProperty.Value;
    /**
     * Soften
     */
    sf?: AnimatedProperty.Value;
    /**
     * Global Angle
     *
     * Use global light
     */
    ga?: AngleValue;
    /**
     * Altitude
     *
     * Local lighting altitude
     */
    ll?: AnimatedProperty.Value;
    /**
     * Highlight Mode
     */
    hm?: AnimatedProperty.Value;
    /**
     * Highlight Color
     */
    hc?: ColorValue;
    /**
     * Highlight Opacity
     */
    ho?: OpacityValue;
    /**
     * Shadow Mode
     */
    sm?: AnimatedProperty.Value;
    /**
     * Shadow Color
     */
    sc?: ColorValue;
    /**
     * Shadow Opacity
     */
    so?: OpacityValue;
  }

  interface Satin
    extends Layer,
      BlendMode,
      Color,
      Opacity,
      Angle,
      Distance,
      Size {
    ty: LayerStyleType.Satin;
    /**
     * Invert
     */
    in?: AnimatedProperty.Value;
  }

  interface ColorOverlay extends Layer, BlendMode, Color {
    ty: LayerStyleType.ColorOverlay;
    /**
     * Opacity
     */
    so?: OpacityValue;
  }

  interface GradientOverlay extends Layer, BlendMode, Opacity, Angle {
    ty: LayerStyleType.GradientOverlay;
    /**
     * Gradient
     */
    gf?: AnimatedProperty.GradientColors;
    /**
     * Smoothness
     */
    gs?: AnimatedProperty.Value;
    /**
     * Gradient Type
     */
    gt?: GradientType.Value;
    /**
     * Reverse
     */
    re?: AnimatedProperty.Value;
    /**
     * Align
     *
     * Align with layer
     */
    al?: AnimatedProperty.Value;
    /**
     * Scale
     */
    s?: AnimatedProperty.Value;
    /**
     * Offset
     */
    of?: AnimatedProperty.Value;
  }

  type Value =
    | Stroke
    | DropShadow
    | InnerShadow
    | OuterGlow
    | InnerGlow
    | BevelEmboss
    | Satin
    | ColorOverlay
    | GradientOverlay;
}

declare type Layer = Layer.Value;
declare namespace Layer {
  interface Main extends Helpers.VisualObject, Helpers.Threedimensional {
    /**
     * Whether the layer is hidden
     */
    hd?: Helpers.Hidden;
    ty: LayerType.Value;
    /**
     * Index that can be used for parenting and referenced in expressions
     * @type integer
     */
    ind?: Helpers.Index;
    /**
     * Parent Index
     *
     * Must be the `ind` property of another Layer
     */
    parent?: number;
    /**
     * Time Stretch
     */
    sr?: Helpers.Time;
    /**
     * In Point - Frame when the layer becomes visible
     */
    ip: Helpers.InPoint;
    /**
     * Out Point - Frame when the layer becomes invisible
     */
    op: Helpers.OutPoint;
    /**
     * Start Time
     */
    st?: Helpers.Time;
  }

  interface AudioSettings {
    /**
     * Level
     */
    lv: AnimatedProperty.MultiDimensional;
  }

  /**
   * A layer playing sounds
   */
  interface Audio extends Main {
    ty: LayerType.Audio;
    au: AudioSettings;
    /**
     * Sound Id
     *
     * ID of the sound as specified in the assets.
     */
    refId?: Helpers.ID;
  }

  /**
   * Layer used to affect visual elements
   */
  interface Visual extends Main {
    /**
     * Collapse Transform
     *
     * This is deprecated in favour of "ct"
     * @deprecated true
     */
    cp?: boolean;
    /**
     * Layer Transform
     */
    ks: Helpers.Transform;
    /**
     * AutoOrient
     *
     * If 1, The layer will rotate itself to match its animated position path
     * @default 0
     */
    ao?: Helpers.IntegerBoolean;
    /**
     * Matte mode, the layer will inherit the transparency from the layer above
     * */
    tt?: MatteMode.Value;
    /**
     * Matte parent
     *
     * Index of the layer used as matte, if omitted assume the layer above the current one
     *
     * "type": "integer"
     */
    tp?: number;
    /**
     * Matte Target
     */
    td?: number;
    /**
     * Whether the layer has masks applied
     */
    hasMask?: boolean;
    /** List of Masks */
    masksProperties?: Helpers.Mask[];
    /**
     * List of Effects
     */
    ef?: Effect.Value[];
    /**
     * Motion Blur
     *
     * Whether motion blur is enabled for the layer
     */
    mb?: boolean;
    /**
     * Layer Style
     *
     * Styling effects for this layer
     */
    sy?: Style.Value[];
    /**
     * Collapse Transform
     *
     * Marks that transforms should be applied before masks
     * @default 0
     */
    ct?: Helpers.IntegerBoolean;
    /**
     * Blend Mode
     * @default 0
     */
    bm?: BlendMode.Value;
    /**
     * CSS class used by the SVG renderer
     */
    cl?: Helpers.CssClass;
    /**
     * Layer XML ID
     *
     * ID attribute used by the SVG renderer
     */
    ln?: Helpers.ID;
    /**
     * Layer XML tag name
     *
     * tag name used by the SVG renderer
     */
    tg?: string;
  }

  /**
   * Layer that renders a Precomposition asset
   */
  interface Precomposition extends Visual {
    ty: LayerType.Precomposition;
    /**
     * Reference ID
     *
     * ID of the precomp as specified in the assets
     */
    refId: Helpers.ID;
    /**
     * Width of the clipping rect
     */
    w: Helpers.Width;
    /**
     * Height of the clipping rect
     */
    h: Helpers.Height;
    /**
     * Time Remapping
     */
    tm?: AnimatedProperty.Value;
  }

  /**
   * Layer containing Shapes
   */
  interface Shape extends Visual {
    ty: LayerType.Shape;
    shapes: Shape.Value[];
  }

  /**
   * Layer with a solid color rectangle
   */
  interface SolidColor extends Visual {
    ty: LayerType.SolidColor;
    /**
     * Color
     *
     * Color of the layer, unlike most other places, the color is a `#rrggbb` hex string
     */
    sc: string;
    /**
     * @default 512
     */
    sh: Helpers.Height;
    /**
     * @default 512
     */
    sw: Helpers.Width;
  }

  /**
   * Layer that shows an image asset
   */
  interface Image extends Visual {
    ty: LayerType.Image;
    /**
     * Image ID
     *
     * ID of the image as specified in the assets
     * @default ""
     */
    refId: Helpers.ID;
  }

  /**
   * Layer with no data, useful to group layers together
   */
  interface Null extends Visual {
    ty: LayerType.Null;
  }

  /**
   * Layer with some text
   */
  interface Text extends Visual {
    ty: LayerType.Text;
    /**
     * Data
     */
    t: Text.Data;
  }

  interface Camera extends Main {
    ty: LayerType.Camera;
    /**
     * Perspective
     *
     * Distance from the Z=0 plane.\nSmall values yield a higher perspective effect.
     */
    pe: AnimatedProperty.Value;
    ks: Helpers.Transform;
  }

  interface Data extends Main {
    ty: LayerType.Data;
    /**
     * Data source ID
     *
     * ID of the data source in assets
     */
    refId?: Helpers.ID;
  }

  interface VideoPlaceholder extends Main {
    ty: LayerType.VideoPlaceholder;
  }

  interface ImageSequence extends Main {
    ty: LayerType.ImageSequence;
  }

  interface Video extends Main {
    ty: LayerType.Video;
  }

  interface ImagePlaceholder extends Main {
    ty: LayerType.ImagePlaceholder;
  }

  interface Guide extends Main {
    ty: LayerType.Guide;
  }

  interface Adjustment extends Main {
    ty: LayerType.Adjustment;
  }

  interface Light extends Main {
    ty: LayerType.Light;
  }

  type Value =
    | Audio
    | Precomposition
    | SolidColor
    | Image
    | Null
    | Shape
    | Text
    | Camera
    | VideoPlaceholder
    | Data
    | ImageSequence
    | Video
    | ImagePlaceholder
    | Guide
    | Adjustment
    | Light;
}

/**
 * Defines named portions of the composition.
 */
type Marker = {
  /**
   * Comment
   */
  cm?: string;
  tm?: Helpers.Time;
  /**
   * Duration
   */
  dr?: number;
};

/**
 * Defines property / image asset overrides.
 */
type Slot = {
  /**
   * Slot Property
   */
  p:
    | AnimatedProperty.MultiDimensional
    | AnimatedProperty.Color
    | AnimatedProperty.Position
    | AnimatedProperty.Shape
    | AnimatedProperty.Value
    | Text.AnimatedDocument
    | Asset.Image;
};

/**
 * Base class for layer holders
 */
interface Composition {
  layers: Layer.Value[];
}

/**
 * Document metadata
 */
interface Metadata {
  /**
   * Author
   */
  a?: string;
  /**
   * Keywords
   */
  k?: string | string[];
  /**
   * Description
   */
  d?: string;
  /**
   * ThemeColor
   */
  tc?: string;
  /**
   * Generator
   *
   * Software used to generate the file
   */
  g?: string;
}

/**
 * Motion blur settings
 */
interface MotionBlur {
  /**
   * Shutter Angle
   *
   * Angle in degrees
   * AE default: 180
   * Skottie default: O ([0, 720])
   */
  sa?: number;
  /**
   * Shutter Phase
   *
   * Angle in degrees
   * AE default: -90
   * Skottie default: 0 ([-360, 360])
   */
  sp?: number;
  /**
   * Samples Per Frame
   * AE default: 16
   * Skottie default: 1 ([1, 64])
   */
  spf?: number;
  /**
   * Adaptive Sample Limit
   *
   * (not yet supported in any known Lottie player)
   * AE default: 128
   * 2D layer motion automatically uses more samples per frame
   * when needed, up to the value specified by Adaptive Sample Limit.
   */
  asl?: number;
}

/**
 * Top level object, describing the animation
 */
interface Animation
  extends Helpers.VisualObject,
    Helpers.Threedimensional,
    Helpers.Framerate,
    Composition {
  /**
   * Version
   * @default 5.5.2
   */
  v?: string;
  /**
   * "In Point", which frame the animation starts at (usually 0)
   * @default 0
   */
  ip: Helpers.InPoint;
  /**
   * "Out Point", which frame the animation stops/loops at, which makes this the duration in frames when `ip` is 0
   * @default 60
   */
  op: Helpers.OutPoint;
  /**
   * Width of the animation
   * @default 512
   */
  w: Helpers.Width;
  /**
   * Height of the animation
   * @default 512
   */
  h: Helpers.Height;
  /**
   * List of assets that can be referenced by layers
   */
  assets?: Asset.Value[];
  /**
   * Extra Compositions
   *
   * List of Extra compositions not referenced by anything
   */
  comps?: Asset.Precomposition[];
  fonts?: Text.FontList;
  /**
   * Data defining text characters as lottie shapes. If present a player
   * might only render characters defined here and nothing else.
   */
  chars?: Text.CharacterData[];
  meta?: Metadata;
  /**
   * User Metadata
   *
   * User-defined metadata
   */
  metadata?: object;
  /**
   * Markers defining named sections of the composition.
   */
  markers?: Marker[];
  mb?: MotionBlur;
  /**
   * Available property overrides
   */
  slots?: {
    [key: Helpers.SlotID]: Slot;
  };
}

declare type Asset = Asset.Value;
declare namespace Asset {
  interface Main extends Helpers.Name {
    /**
     * ID
     *
     * Unique identifier used by layers when referencing this asset
     * @default ""
     */
    id: string;
  }

  /**
   * Asset referencing a file
   */
  interface File extends Main {
    /**
     * Path
     *
     * Path to the directory containing an asset file
     * @default ""
     */
    u?: string;
    /**
     * Filename or Data URL
     */
    p: string;
    /**
     * Embedded
     *
     * Whether the asset is embedded
     * @default 0
     */
    e?: Helpers.IntegerBoolean;
  }

  /**
   * External image
   */
  interface Image extends File {
    /**
     * Width of the image
     * @default 0
     */
    w?: Helpers.Width;
    /**
     *
     * Height of the image
     * @default 0
     */
    h?: Helpers.Height;
    /**
     * Type
     * Marks as part of an image sequence if present
     */
    t?: "seq";
    /**
     * Slot ID
     *
     * One of the ID in the file's slots
     */
    sid?: Helpers.SlotID;
  }

  /**
   * External sound
   */
  interface Sound extends File {}

  /**
   * Asset containing an animation that can be referenced by layers.
   */
  interface Precomposition extends Main, Composition, Helpers.Framerate {
    /**
     * Extra
     *
     * Extra composition
     * @default 0
     */
    xt?: Helpers.IntegerBoolean;
  }

  /**
   * External data source, usually a JSON file"
   */
  interface DataSource extends File {
    /**
     * Type
     * @type integer
     */
    t: 3;
  }

  type Value = Image | Precomposition | Sound | DataSource;
}

export {
  AnimatedProperty,
  Animation,
  Asset,
  BlendMode,
  Composite,
  Composition,
  Effect,
  EffectType,
  EffectValue,
  EffectValueType,
  FillRule,
  GradientType,
  Helpers,
  Layer,
  LayerStyleType,
  LayerType,
  LineCap,
  LineJoin,
  Marker,
  MaskMode,
  MatteMode,
  Metadata,
  MotionBlur,
  PolyStarType,
  Shape,
  ShapeDirection,
  ShapeType,
  Slot,
  StrokeDashType,
  Style,
  Text,
  TextType,
  TrimMultipleShapes,
};
